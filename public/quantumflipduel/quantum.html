<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quantum Flip Game</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    html, body {
      margin: 0; padding: 0;
      font-family: system-ui,Arial,sans-serif;
      background: #000;
      min-height: 100vh;
      min-width: 100vw;
      overflow: hidden;
    }
    #root {
      width: 100vw;
      height: 100vh;
      min-width: 100vw;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: stretch;
    }
    .fullscreen-panel {
      width: 100vw;
      height: 100vh;
      min-height: 100vh;
      min-width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(ellipse at 60% 50%, #0ff2 0%, #011 100%);
      position: absolute;
      top: 0; left: 0;
      z-index: 1;
    }
    .panel-content {
      width: 100vw;
      max-width: 700px;
      margin: 0 auto;
      padding: 0 3vw;
      text-align: center;
      color: #fff;
      margin-top: 4vh;
      margin-bottom: 4vh;
      z-index: 2;
    }
    h1, h2 { color: #0ff; text-shadow: 0 0 16px #0ff8; }
    .coin {
      color: #0ff;
      font-weight: bold;
      text-shadow: 0 0 8px #0ff, 0 0 5px #fff8;
      font-size: 1.2em;
    }
    .menu-btn {
      width: 320px;
      max-width: 80vw;
      margin: 18px auto;
      padding: 18px 0;
      font-size: 1.4em;
      background: linear-gradient(90deg, #0ff 30%, #88f 100%);
      color: #000;
      border-radius: 12px;
      border: none;
      box-shadow: 0 4px 22px #0ff5;
      cursor: pointer;
      font-weight: bold;
      letter-spacing: 1px;
      transition: background .12s, color .12s;
      text-shadow: 0 0 10px #fff8;
      display:block;
    }
    .menu-btn:hover { background: linear-gradient(90deg, #0cf 10%, #0ff 90%); color: #fff;}
    .back-btn {
      padding: 12px 36px;
      margin-top: 32px;
      background: #111;
      color: #0ff;
      border: 2px solid #0ff;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1.1em;
      font-weight: bold;
      box-shadow: 0 0 12px #0ff7;
      transition: background .14s, color .14s;
    }
    .back-btn:hover { background: #0ff; color: #000; }
    .shop-spell {
      border: 2px solid #0ff6;
      border-radius: 12px;
      padding: 18px 6px 18px 12px;
      margin: 16px 2px;
      background: #011218;
      text-align: left;
      transition: background .2s, border .2s;
      position: relative;
      font-size: 1em;
      box-shadow: 0 0 24px #0ff3;
      max-width: 460px;
      margin-left:auto;
      margin-right:auto;
    }
    .shop-spell.owned { background: #022e1c; border-color:#0f06; }
    .shop-spell .spell-title { font-weight: bold; font-size: 1.2em; color:#0ff; text-shadow:0 0 5px #0ff9;}
    .shop-spell .spell-desc { font-size: 1em; color: #bff; white-space: pre-line; }
    .shop-spell .spell-cost { color: #0ff; font-weight: bold; }
    .shop-spell button {
      margin-top: 7px;
      background: #0ff;
      color: #000; border: none; border-radius: 8px;
      padding: 8px 28px; cursor: pointer;
      font-weight: bold;
      float: right;
      font-size:1em;
      box-shadow: 0 0 18px #0ff7;
      transition: background .13s, color .13s;
    }
    .shop-spell button:disabled { background: #099; color:#555; cursor: not-allowed; }
    .difficulty-select {
      margin-top: 38px;
      font-size: 1.2em;
      padding: 10px 24px;
      border-radius: 12px;
      border: 2px solid #0ff;
      background: #021e24;
      color:#0ff;
      text-align:center;
    }
    /* ---- BOARD ---- */
    .fullscreen-board {
      width: 100vw;
      height: 100vh;
      min-width: 100vw;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: stretch;
      background: linear-gradient(90deg,#fff2 0 50%,#0ff2 50% 100%);
      box-shadow: 0 0 0 0;
      z-index: 1;
      position: absolute;
      top: 0;
      left: 0;
    }
    .board-topbar {
      width: 100vw;
      padding: 2vh 2vw 0 2vw;
      display: flex;
      justify-content: center;
      align-items: center;
      color: #0ff;
      font-size: 1.3em;
      z-index: 2;
      text-shadow: 0 0 6px #0ff;
      font-weight:bold;
    }
    .moves-center {
      flex: 0 0 auto;
      margin: 0 20px;
      font-size: 1.25em;
      letter-spacing:2px;
      color: #0ff;
      text-shadow:0 0 8px #0ff;
      background:rgba(0,0,0,0.30);
      padding: 6px 22px;
      border-radius:12px;
      border:2px solid #0ff8;
      box-shadow: 0 0 15px #0ff5;
      font-weight:bold;
    }
    .info-bar {
      width:100vw;
      font-size: 1.05em;
      color: #0ff;
      text-shadow: 0 0 7px #0ff5;
      display: block;
      margin: 10px 0 3px 0;
      text-align: center;
      z-index: 2;
    }
    .board-wrap {
      flex: 1 1 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      height:100%;
      width:100vw;
      min-height: 0;
      min-width: 0;
    }
    .board {
      display: grid;
      grid-template-rows: repeat(10,1fr);
      grid-template-columns: repeat(10,1fr);
      gap: 3px;
      background: #000;
      border-radius: 22px;
      box-shadow: 0 0 60px #0ff9,0 0 12px #fff9;
      margin: 0 auto;
      width: min(90vw, 90vh);
      height: min(90vw, 90vh);
      max-width: 80vw;
      max-height: 80vw;
      aspect-ratio: 1/1;
      position: relative;
    }
    .board-cell {
      width: 100%;
      height: 100%;
      border-radius: 7px;
      border: 1.5px solid #068;
      box-sizing: border-box;
      font-size: 1.1em;
      cursor: pointer;
      background: #000;
      transition: background 0.18s, border 0.18s, box-shadow 0.18s;
      position: relative;
      user-select: none;
      box-shadow: 0 0 13px #0ff5, 0 0 2px #fff2;
      overflow: hidden;
      z-index: 1;
    }
    .board-cell.left-half { border-left: 2.5px solid #fff4; }
    .board-cell.right-half { border-right: 2.5px solid #0ff7; }
    .board-cell.ai {
      background: radial-gradient(circle, #023 60%, #0ff 100%);
      box-shadow: 0 0 17px #0ff9, 0 0 6px #00fffa99;
      border-color:#0ff;
      color: #fff;
    }
    .board-cell.player {
      background: radial-gradient(circle, #181826 50%, #fff 100%);
      box-shadow: 0 0 17px #fff9, 0 0 6px #0ff2;
      border-color: #fff;
      color: #000;
    }
    .board-cell.quantum {
      background: linear-gradient(120deg,#0ff,#44f 60%);
      box-shadow: 0 0 8px #0ff7,0 0 22px #4ff4;
      border-color:#44f;
    }
    .board-cell.quantum.visible {
      background: repeating-linear-gradient(45deg,#aaf 0 4px,#fff 4px 8px);
    }
    .board-cell.last-move {
      outline: 3px solid #f00 !important;
      z-index: 2;
      box-shadow: 0 0 20px #f08a, 0 0 8px #fff9;
    }
    .spell-bar {
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 18px 0 0 0;
      flex-wrap: wrap;
    }
    .spell-btn {
      margin: 7px 11px 7px 0;
      padding: 10px 29px;
      background: linear-gradient(90deg,#0ff 40%,#44f 100%);
      color: #000;
      border: none; border-radius: 9px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1.1em;
      box-shadow: 0 0 18px #0ff4;
      transition: background .13s, color .13s;
      outline: none;
    }
    .spell-btn:disabled { background: #022; color: #066; cursor: not-allowed; }
    .spell-btn.selected { outline: 2px solid #ff0; background: #222; color:#0ff;}
    .spell-info {
      font-size: 1em;
      color: #0ff;
      margin: 6px 0 0 0;
      text-align: center;
      text-shadow: 0 0 7px #0ff5;
    }
    .overlay {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      background: #000a;
      z-index: 1000;
      display: flex;
      align-items: center; justify-content: center;
    }
    .overlay-inner {
      background: #0ff;
      color: #111;
      padding: 60px 36px 40px 36px;
      border-radius: 22px;
      min-width: 320px;
      box-shadow: 0 10px 60px #0ffb;
      text-align: center;
      font-size: 2.2em;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
    }
    .overlay-inner .small {
      font-size: 1.1em;
      margin-top: 30px;
      color: #099;
    }
    @media (max-width: 800px) {
      .board { max-width: 97vw; max-height: 97vw; }
      .fullscreen-panel, .fullscreen-board { max-width: 100vw; max-height: 100vh;}
      .panel-content { max-width: 95vw;}
      .shop-spell { max-width: 96vw;}
    }
    @media (max-width: 500px) {
      .board { max-width: 99vw; max-height: 99vw; }
      .panel-content { max-width: 99vw;}
      .shop-spell { max-width: 99vw;}
      .board-cell { font-size: 0.7em; }
      .spell-btn { font-size: 0.7em; padding: 7px 10px;}
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
    // ----------- State -----------
    let coins = 0;
    let spellsOwned = [];
    let difficulty = 0; // 0=easy,1=med,2=hard,3=extreme
    let screen = "menu";
    let gameState = null;
    let overlay = null;

    const SPELLS = [
      {
        key: "quantum",
        name: "Quantum Split",
        desc: `A single move, many futures.\nSplits a piece into 2-3 possible states; opponent sees all, but only one is realâ€”revealed when targeted.`,
        cost: 30,
        mana: 20
      },
      {
        key: "collapse",
        name: "Waveform Collapse",
        desc: `Everything becomes... definite.\nCollapses all superpositioned pieces on the board to their actual states. Good for revealing enemy tricks or final strikes.`,
        cost: 20,
        mana: 50
      },
      {
        key: "fireball",
        name: "Fireball",
        desc: `Casts a fireball in a 4x4 area, flipping all squares inside.`,
        cost: 18,
        mana: 40
      },
      {
        key: "skip",
        name: "Skip",
        desc: `Skips the opponent's move, giving you two in a row.`,
        cost: 25,
        mana: 35
      }
    ];
    const DIFFICULTY_LEVELS = ["Easy", "Medium", "Hard", "Extreme"];
    const BOARD_SIZE = 10, INIT_MANA = 100, MANA_REGEN = 8, MAX_MOVES = 70;

    // --- Random Events ---
    const RANDOM_EVENTS = [
      {
        name: "Flip Random Row",
        run(gs) {
          const row = Math.floor(Math.random() * BOARD_SIZE);
          for (let c = 0; c < BOARD_SIZE; c++)
            flip(gs.board, row, c, Math.random() < 0.5 ? 0 : 1);
          showOverlay(`Random Event: A mysterious force flips all of row ${row+1}!`);
        }
      },
      {
        name: "Flip Random Column",
        run(gs) {
          const col = Math.floor(Math.random() * BOARD_SIZE);
          for (let r = 0; r < BOARD_SIZE; r++)
            flip(gs.board, r, col, Math.random() < 0.5 ? 0 : 1);
          showOverlay(`Random Event: Lightning strikes column ${col+1} and flips it!`);
        }
      },
      {
        name: "Color Surge",
        run(gs) {
          // Convert 6 random tiles to a random color
          for(let i=0;i<6;i++) {
            let r = Math.floor(Math.random()*BOARD_SIZE);
            let c = Math.floor(Math.random()*BOARD_SIZE);
            gs.board[r][c] = Math.random()<0.5?0:1;
          }
          showOverlay("Random Event: Color Surge! 6 random tiles have shifted color.");
        }
      },
      {
        name: "Mana Burst",
        run(gs) {
          gs.mana += 15;
          gs.aiMana += 15;
          showOverlay("Random Event: Mana Burst! Both players gain 15 mana.");
        }
      },
      {
        name: "Quantum Storm",
        run(gs) {
          // Turn 4 random AI squares into quantum pieces
          for(let i=0;i<4;i++) {
            let r = Math.floor(Math.random()*BOARD_SIZE);
            let c = Math.floor(Math.random()*BOARD_SIZE/2) + BOARD_SIZE/2; // right half
            if (gs.board[r][c] === 1) {
              let states = [0,1];
              if (Math.random()<0.5) states.push(1);
              const trueState = states[Math.floor(Math.random()*states.length)];
              gs.board[r][c] = {quantum:true,states,trueState,visible:false};
            }
          }
          showOverlay("Random Event: Quantum Storm! Some AI squares split into quantum states.");
        }
      }
    ];

    // ----------- Rendering -----------
    function render() {
      const root = document.getElementById('root');
      root.innerHTML = '';
      if (screen === "menu") root.appendChild(renderMenu());
      else if (screen === "settings") root.appendChild(renderSettings());
      else if (screen === "shop") root.appendChild(renderShop());
      else if (screen === "tutorial") root.appendChild(renderTutorial());
      else if (screen === "play") root.appendChild(renderPlay());
      if (overlay) root.appendChild(renderOverlay(...overlay));
    }
    // ----------- UI PARTS -----------
    function renderMenu() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.innerHTML = `
        <h1>Quantum Flip</h1>
        <div style="margin:16px 0 40px 0;">
          <span class="coin" style="font-size:2.2em;">Coins: ${coins} ðŸª™</span>
        </div>
      `;
      content.appendChild(menuBtn("Play", ()=>startGame()));
      content.appendChild(menuBtn("Tutorial", ()=>{screen="tutorial"; render();}));
      content.appendChild(menuBtn("Shop", ()=>{screen="shop"; render();}));
      content.appendChild(menuBtn("Settings", ()=>{screen="settings"; render();}));
      const by = document.createElement('div');
      by.style.marginTop = "53px";
      by.style.fontSize = "1.1em";
      by.style.color = "#0ff";
      by.innerHTML = 'by <b>skibiditoile3qb</b> | neon vanilla JS demo';
      content.appendChild(by);
      panel.appendChild(content);
      return panel;
    }
    function menuBtn(text, cb) {
      const btn = document.createElement('button');
      btn.className = "menu-btn";
      btn.innerText = text;
      btn.onclick = cb;
      return btn;
    }
    function renderSettings() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.innerHTML = `<h2>Settings</h2>
        <div style="margin-bottom:24px">
          <b>AI Difficulty:</b>
          <br>
          <select class="difficulty-select" id="diffsel">
            ${DIFFICULTY_LEVELS.map((d,i)=>`<option value="${i}"${i==difficulty?' selected':''}>${d}</option>`).join('')}
          </select>
        </div>
      `;
      setTimeout(()=>{
        document.getElementById('diffsel').onchange = e=>{
          difficulty = +e.target.value;
        };
      },10);
      content.appendChild(backBtn());
      panel.appendChild(content);
      return panel;
    }
    function renderShop() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.innerHTML = `<div style="margin-bottom:14px;">
        <b>Coins:</b> <span class="coin">${coins} ðŸª™</span>
      </div>
      <h2>Shop</h2>`;
      SPELLS.forEach(spell=>{
        const owned = spellsOwned.includes(spell.key);
        const spellDiv = document.createElement('div');
        spellDiv.className = 'shop-spell'+(owned?' owned':'');
        spellDiv.innerHTML = `
          <div class="spell-title">${spell.name}</div>
          <div class="spell-desc">${spell.desc}</div>
          <div>
            <span class="spell-cost">${spell.cost} ðŸª™</span>
            <span style="margin-left:12px; color:#0ff;">Use: ${spell.mana} mana</span>
          </div>
        `;
        const btn = document.createElement('button');
        btn.innerText = owned ? "Owned" : "Buy";
        btn.disabled = owned || coins < spell.cost;
        btn.onclick = ()=>{
          if (owned || coins < spell.cost) return;
          coins -= spell.cost;
          spellsOwned.push(spell.key);
          render();
        };
        spellDiv.appendChild(btn);
        content.appendChild(spellDiv);
      });
      content.appendChild(backBtn());
      panel.appendChild(content);
      return panel;
    }
    function renderTutorial() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.style.textAlign = "left";
      content.style.maxWidth = "650px";
      content.innerHTML = `
        <h2>Tutorial</h2>
        <ol>
          <li><b>The Goal:</b> Flip as many tiles to your color (white-neon) as possible before 70-move countdown ends.</li>
          <li><b>Turns:</b> You and the AI take turns. Each turn, click any <b>AI (aqua)</b> square; it and all adjacent squares (not corners) flip.</li>
          <li><b>Mana:</b> Each turn you regain 8 mana. Spells cost mana to cast.</li>
          <li><b>Spells:</b> Buy spells in the Shop, then select a spell in-game to use its effect!</li>
          <li><b>End:</b> When moves run out, whoever has more squares of their color wins and gets 10 coins!</li>
          <li><b>AI:</b> The higher the difficulty, the smarter the AI's moves. AI/Player cannot repeat the other's last move.</li>
          <li><b>Random Events:</b> Every 5 moves, a random event may occur!</li>
        </ol>
      `;
      content.appendChild(backBtn());
      panel.appendChild(content);
      return panel;
    }
    function backBtn() {
      const btn = document.createElement('button');
      btn.className = "back-btn";
      btn.innerText = "Back";
      btn.onclick = ()=>{screen="menu"; render();};
      return btn;
    }
    // ----------- GAME LOGIC -----------
    function startGame() {
      let board = Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(1));
      for (let r=0;r<BOARD_SIZE;r++) for (let c=0;c<BOARD_SIZE;c++) 
        if (c<BOARD_SIZE/2) board[r][c]=0; // left half player, right half AI
      gameState = {
        board,
        mana: INIT_MANA,
        aiMana: INIT_MANA,
        turn: 0, // 0=player, 1=ai
        movesLeft: MAX_MOVES,
        winner: null,
        skip: false,
        quantumPieces: [],
        spellOn: null,
        usedSkip: false,
        lastPlayerMove: null,  // {r,c}
        lastAIMove: null,      // {r,c}
        movesPlayed: 0
      };
      screen = "play";
      render();
    }
    function renderPlay() {
      const gs = gameState;
      const panel = document.createElement('div');
      panel.className = "fullscreen-board";
      // Top bar
      panel.innerHTML = `
        <div class="board-topbar">
          <span class="moves-center"><b>Moves Left:</b> ${gs.movesLeft}</span>
        </div>
        <div class="info-bar">
          <span style="margin-right:14px;"><b>Mana:</b> ${gs.mana} <span style="color:#0ff;">ðŸ’ </span></span>
          <span style="margin-right:14px;"><b>Your:</b> ${countBoard(gs.board,0)} <span style="color:#fff;">â¬œ</span></span>
          <span><b>AI:</b> ${countBoard(gs.board,1)} <span style="color:#0ff;">â¬›</span></span>
        </div>`;
      // Board
      const boardWrap = document.createElement('div');
      boardWrap.className = 'board-wrap';
      const boardDiv = document.createElement('div');
      boardDiv.className = "board";
      for (let r=0; r<BOARD_SIZE; r++) {
        for (let c=0; c<BOARD_SIZE; c++) {
          const cell = gs.board[r][c];
          const cellDiv = document.createElement('div');
          cellDiv.className = "board-cell";
          if (c < BOARD_SIZE/2) cellDiv.classList.add("left-half");
          else cellDiv.classList.add("right-half");
          if (cell===0) cellDiv.classList.add("player");
          else if (cell===1) cellDiv.classList.add("ai");
          else if (typeof cell==='object' && cell.quantum) {
            cellDiv.classList.add("quantum");
            if (cell.visible) cellDiv.classList.add("visible");
          }
          // Last move highlight
          if ((gs.lastPlayerMove && gs.lastPlayerMove.r===r && gs.lastPlayerMove.c===c) ||
              (gs.lastAIMove && gs.lastAIMove.r===r && gs.lastAIMove.c===c)) {
            cellDiv.classList.add("last-move");
          }
          cellDiv.onclick = ()=>handleCellClick(r,c);
          // Quantum marker
          if (typeof cell==='object' && cell.quantum) {
            cellDiv.innerHTML = `<span style="position:absolute;left:2px;top:2px;font-size:1.1em;color:#fff;text-shadow:0 0 10px #44f;font-weight:bold;">Q</span>`;
          }
          // Disallow if last AI move for player, last player move for AI
          if (gs.turn===0 && gs.lastAIMove && gs.lastAIMove.r===r && gs.lastAIMove.c===c) {
            cellDiv.style.opacity = 0.45;
            cellDiv.title = "Can't play in the same spot as the AI's last move!";
          }
          if (gs.turn===1 && gs.lastPlayerMove && gs.lastPlayerMove.r===r && gs.lastPlayerMove.c===c) {
            cellDiv.style.opacity = 0.45;
            cellDiv.title = "Can't play in the same spot as the player's last move!";
          }
          boardDiv.appendChild(cellDiv);
        }
      }
      boardWrap.appendChild(boardDiv);
      panel.appendChild(boardWrap);
      // Spells
      const spellsDiv = document.createElement('div');
      spellsDiv.className = 'spell-bar';
      SPELLS.forEach(spell=>{
        const owned = spellsOwned.includes(spell.key);
        const btn = document.createElement('button');
        btn.innerText = spell.name;
        btn.className = "spell-btn"+(gs.spellOn===spell.key?' selected':'');
        btn.disabled = !owned || gs.mana < spell.mana || (spell.key==="skip" && gs.usedSkip);
        btn.onclick = ()=>{
          if (!owned || gs.mana < spell.mana) return;
          if (spell.key==="collapse") { handleCollapseSpell(); return; }
          if (spell.key==="skip") { handleSkipSpell(); return; }
          gs.spellOn = spell.key;
          render();
        };
        spellsDiv.appendChild(btn);
      });
      panel.appendChild(spellsDiv);
      const spellInfo = document.createElement('div');
      spellInfo.className = 'spell-info';
      spellInfo.innerText = "(Select a spell to use it on your next move.)";
      panel.appendChild(spellInfo);

      // Winner overlay
      if (gs.winner) showOverlay(gs.winner, () => { screen="menu"; overlay = null; render(); });
      return panel;
    }
    // -- Helper functions for Play
    function countBoard(board, val) {
      let n=0;
      for (let r=0;r<BOARD_SIZE;r++)
        for (let c=0;c<BOARD_SIZE;c++)
          if (board[r][c]===val||(typeof board[r][c]==='object'&&board[r][c].quantum&&board[r][c].visible&&board[r][c].states.includes(val))) n++;
      return n;
    }
    function handleCellClick(r,c) {
      const gs = gameState;
      if (gs.winner||gs.turn!==0) return;
      if (gs.lastAIMove && gs.lastAIMove.r===r && gs.lastAIMove.c===c) return;
      let cell = gs.board[r][c];
      if (typeof cell==='object' && cell.quantum) {
        if (!cell.visible) return;
        cell = cell.states[0];
      }
      if (cell!==1) return; // can only flip AI squares
      // Handle spell use
      if (gs.spellOn) {
        const spellKey = gs.spellOn;
        if (!spellsOwned.includes(spellKey)) return;
        if (spellKey==="quantum") {
          let states=[0,1];
          if (Math.random()<0.5) states.push(1);
          const trueState = states[Math.floor(Math.random()*states.length)];
          gs.board[r][c] = {quantum:true,states,trueState,visible:false};
          gs.mana -= SPELLS.find(s=>s.key===spellKey).mana;
          gs.spellOn = null;
          gs.movesLeft--;
          gs.turn = 1;
          gs.quantumPieces.push({r,c});
          gs.lastPlayerMove = {r,c};
          gs.movesPlayed++;
          checkRandomEvent(gs);
          render();
          setTimeout(()=>aiMove(gs),900);
          return;
        }
        if (spellKey==="fireball") {
          for (let dr=0;dr<4;dr++) for (let dc=0;dc<4;dc++) {
            let nr=r+dr-1, nc=c+dc-1;
            if (nr>=0&&nr<BOARD_SIZE&&nc>=0&&nc<BOARD_SIZE) {
              if (typeof gs.board[nr][nc]==='object'&&gs.board[nr][nc].quantum) gs.board[nr][nc]=gs.board[nr][nc].trueState;
              else gs.board[nr][nc]=0;
            }
          }
          gs.mana -= SPELLS.find(s=>s.key===spellKey).mana;
          gs.spellOn = null;
          gs.movesLeft--;
          gs.turn = 1;
          gs.lastPlayerMove = {r,c};
          gs.movesPlayed++;
          checkRandomEvent(gs);
          render();
          setTimeout(()=>aiMove(gs),900);
          return;
        }
      }
      // Standard flip
      flip(gs.board, r, c, 0);
      gs.movesLeft--;
      gs.turn = 1;
      gs.mana += MANA_REGEN;
      gs.lastPlayerMove = {r,c};
      gs.movesPlayed++;
      checkRandomEvent(gs);
      if (gs.movesLeft<=0) {
        const w = countBoard(gs.board,0), bl = countBoard(gs.board,1);
        endGame(w>bl?1:w<bl?0:null);
        return;
      }
      render();
      setTimeout(()=>aiMove(gs),900);
    }
    function flip(board, r, c, color) {
      const dirs = [[0,0],[-1,0],[1,0],[0,-1],[0,1]];
      for (const [dr,dc] of dirs) {
        let nr=r+dr,nc=c+dc;
        if (nr>=0&&nr<BOARD_SIZE&&nc>=0&&nc<BOARD_SIZE) {
          if (typeof board[nr][nc]==='object'&&board[nr][nc].quantum) board[nr][nc]=board[nr][nc].trueState;
          else board[nr][nc]=color;
        }
      }
    }
    function handleCollapseSpell() {
      const gs = gameState;
      if (!spellsOwned.includes("collapse")||gs.mana<SPELLS.find(s=>s.key==="collapse").mana) return;
      for (let r=0;r<BOARD_SIZE;r++) for (let c=0;c<BOARD_SIZE;c++)
        if (typeof gs.board[r][c]==='object'&&gs.board[r][c].quantum) gs.board[r][c]=gs.board[r][c].trueState;
      gs.mana -= SPELLS.find(s=>s.key==="collapse").mana;
      gs.spellOn = null;
      gs.movesLeft--;
      gs.turn = 1;
      gs.movesPlayed++;
      checkRandomEvent(gs);
      render();
      setTimeout(()=>aiMove(gs),900);
    }
    function handleSkipSpell() {
      const gs = gameState;
      if (!spellsOwned.includes("skip")||gs.mana<SPELLS.find(s=>s.key==="skip").mana||gs.usedSkip) return;
      gs.mana -= SPELLS.find(s=>s.key==="skip").mana;
      gs.skip = true;
      gs.usedSkip = true;
      gs.spellOn = null;
      gs.movesLeft--;
      gs.turn = 1;
      gs.movesPlayed++;
      checkRandomEvent(gs);
      render();
      setTimeout(()=>aiMove(gs),900);
    }
    function endGame(playerWon) {
      const gs = gameState;
      gs.winner = playerWon ? "You win! +10 coins" : playerWon===null ? "Draw!" : "AI wins!";
      if (playerWon) coins += 10;
      overlay = [gs.winner, () => { screen="menu"; overlay = null; render(); }];
      render();
    }
    // --- AI MOVE ---
    function aiMove(gs) {
      if (gs.winner) return;
      if (gs.skip) { gs.skip=false; gs.turn=0; gs.usedSkip=true; gs.movesPlayed++; checkRandomEvent(gs); render(); return; }
      const moves=[];
      for (let r=0;r<BOARD_SIZE;r++)
        for (let c=0;c<BOARD_SIZE;c++)
          if (gs.board[r][c]===0) {
            if (gs.lastPlayerMove && gs.lastPlayerMove.r===r && gs.lastPlayerMove.c===c) continue;
            const b2 = JSON.parse(JSON.stringify(gs.board));
            flip(b2,r,c,1);
            const gain = countBoard(b2,1)-countBoard(gs.board,1);
            moves.push({r,c,gain,b2});
          }
      let move=null;
      if (moves.length===0) { gs.turn=0; render(); return; }
      let sortedMoves=[...moves].sort((a,b)=>b.gain-a.gain);
      if (difficulty===0) {
        let top=sortedMoves.slice(0,25); move=top[Math.floor(Math.random()*top.length)];
      } else if (difficulty===1) {
        let top=sortedMoves.slice(0,15); move=top[Math.floor(Math.random()*top.length)];
      } else if (difficulty===2) {
        let top=sortedMoves.slice(0,3); move=top[Math.floor(Math.random()*top.length)];
      } else if (difficulty===3) {
        // Extreme: depth 2, best minimax, only valid moves
        let best=-Infinity;
        for (const m of sortedMoves.slice(0,6)) {
          let bestReply=-Infinity;
          for (let rr=0;rr<BOARD_SIZE;rr++) for (let cc=0;cc<BOARD_SIZE;cc++)
            if (m.b2[rr][cc]===1) { // Only allow player on AI's squares
              if (m.r===rr && m.c===cc) continue;
              let b3=JSON.parse(JSON.stringify(m.b2));
              flip(b3,rr,cc,0);
              let v=countBoard(b3,1)-countBoard(m.b2,1);
              if (v>bestReply) bestReply=v;
            }
          let value = m.gain-(bestReply||0);
          if (value>best) { best=value; move=m; }
        }
      }
      if (!move) move=sortedMoves[0];
      if (!move) { gs.turn=0; render(); return; }
      gs.board = move.b2;
      for (let r=0;r<BOARD_SIZE;r++)
        for (let c=0;c<BOARD_SIZE;c++)
          if (typeof gs.board[r][c]==='object'&&gs.board[r][c].quantum&&!gs.board[r][c].visible)
            gs.board[r][c].visible=true;
      gs.movesLeft--;
      gs.aiMana+=MANA_REGEN;
      gs.turn=0;
      gs.lastAIMove = {r:move.r,c:move.c};
      gs.movesPlayed++;
      checkRandomEvent(gs);
      if (gs.movesLeft<=0) {
        const w = countBoard(gs.board,0), bl = countBoard(gs.board,1);
        endGame(w>bl?1:w<bl?0:null);
        return;
      }
      render();
    }
    // ----------- Random Event check --------
    function checkRandomEvent(gs) {
      if (!gs.winner && gs.movesPlayed > 0 && gs.movesPlayed % 5 === 0) {
        // 50% chance each event time
        if (Math.random() < 0.5) {
          const event = RANDOM_EVENTS[Math.floor(Math.random()*RANDOM_EVENTS.length)];
          event.run(gs);
        }
      }
    }
    // ----------- Overlay -----------
    function showOverlay(msg, cb) {
      overlay=[msg, cb];
      render();
    }
    function renderOverlay(msg, cb) {
      const div = document.createElement('div');
      div.className = "overlay";
      div.onclick = ()=>{
        overlay=null;
        if (cb) cb();
        render();
      };
      div.innerHTML = `<div class="overlay-inner">${msg}<div class="small">(Click to continue)</div></div>`;
      return div;
    }
    // ----------- INIT -----------
    window.onload = render;
  </script>
</body>
</html>
