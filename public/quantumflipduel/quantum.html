<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quantum Flip Game</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://fonts.googleapis.com/css?family=Orbitron:wght@700&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0; padding: 0;
      font-family: 'Orbitron', Arial, sans-serif;
      background: #10131a;
      min-height: 100vh;
      min-width: 100vw;
      width: 100vw;
      height: 100vh;
      overflow-x: hidden;
      overflow-y: auto;
    }
    #root {
      width: 100vw;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
      position: relative;
      z-index: 0;
      background: #10131a;
    }
    .topbar {
      width: 100vw;
      min-height: 60px;
      background: #181f2a;
      border-bottom: 1.5px solid #232b39;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      z-index: 2;
      position: relative;
      box-shadow: 0 2px 12px #0003;
    }
    .moves-counter {
      font-family: 'Orbitron', monospace, Arial, sans-serif;
      font-size: 2em;
      color: #18e6e6;
      margin-top: 4px;
      font-weight: bold;
      letter-spacing: 2px;
      background: none;
      padding: 3px 0 2px 0;
      border-radius: 12px;
      text-shadow: 0 2px 0 #fff3, 0 0 6px #18e6e6a1;
    }
    .info-bar {
      width: 100vw;
      font-size: 1em;
      color: #18e6e6;
      background: none;
      display: flex;
      justify-content: center;
      gap: 32px;
      align-items: center;
      margin: 0;
      padding: 2px 0 8px 0;
      font-family: inherit;
      font-weight: 600;
      letter-spacing: 1px;
    }
    .game-main {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: 100vw;
      min-height: 0;
      background: #10131a;
      position: relative;
    }
    .board-wrap {
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 26px;
      margin-bottom: 8px;
      min-height: 0;
      z-index: 1;
    }
    .board {
      display: grid;
      grid-template-rows: repeat(10,1fr);
      grid-template-columns: repeat(10,1fr);
      gap: 3px;
      background: #12141e;
      border-radius: 18px;
      margin: 0 auto;
      width: min(70vw, 70vh);
      height: min(70vw, 70vh);
      max-width: 97vw;
      max-height: 97vw;
      aspect-ratio: 1/1;
      position: relative;
      border: 1.5px solid #232b39;
      box-shadow: 0 2px 24px #0007;
      transition: box-shadow 0.2s;
    }
    .board-cell {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      border: 2px solid #2cf3fb;
      box-sizing: border-box;
      font-size: 1.15em;
      cursor: pointer;
      background: #07090d;
      position: relative;
      user-select: none;
      box-shadow: 0 1px 2.5px #0005;
      overflow: hidden;
      z-index: 1;
      transition: background 0.22s, border 0.15s, box-shadow 0.12s, filter 0.18s, transform 0.23s;
      filter: brightness(1);
      animation: none !important;
    }
    .board-cell.player {
      background: #fff;
      border: 2.5px solid #dbeafe;
      box-shadow: 0 0 5px #dbeafe77;
    }
    .board-cell.ai {
      background: #07090d;
      border: 2.5px solid #18e6e6;
      box-shadow: 0 0 5px #18e6e655;
    }
    .board-cell.mana-tile {
  background: linear-gradient(135deg, #00f0ff 60%, #fff 100%);
  border: 2.5px solid #18e6e6;
  box-shadow: 0 0 8px #18e6e6cc;
}
    .board-cell.quantum {
      background: repeating-linear-gradient(45deg, #3ff 0 5px, #fff 6px 14px);
      border: 2.5px dashed #44f;
    }
    .board-cell.quantum.visible {
      background: linear-gradient(120deg,#0ff,#44f 60%);
      border-style: solid;
    }
    .board-cell.last-move {
      outline: 3px solid #f00 !important;
      z-index: 10;
      box-shadow: 0 0 18px #f003, 0 0 10px #f00b, 0 0 5px #f00;
      animation: lastMovePulse 0.8s cubic-bezier(.53,2,.44,.98) alternate;
    }
    @keyframes lastMovePulse {
      0% { box-shadow: 0 0 0px #f003;}
      60% { box-shadow: 0 0 22px #f00a, 0 0 18px #f00b;}
      100% { box-shadow: 0 0 18px #f003, 0 0 10px #f00b, 0 0 5px #f00;}
    }
 
 @keyframes flipColor {
  0% { background: var(--start-color); }
  50% { background: var(--start-color); }
  51% { background: var(--end-color); }
  100% { background: var(--end-color); }
}

   .board-cell-inner {
  width: 100%; height: 100%;
  border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  transform-style: preserve-3d;
  will-change: transform;
  backface-visibility: hidden;
}
.board-cell.flipping .board-cell-inner {
  animation: inherit;
}
   @keyframes flip3d {
  0% { transform: scaleX(1); }
  50% { transform: scaleX(0); }
  100% { transform: scaleX(1); }
}
    .board-cell:hover {
      filter: brightness(1.12);
      border-color: #ff0;
      z-index: 2;
      
    }
    .board-cell.boost-tile {
  background: linear-gradient(135deg, #ffd700 60%, #fff 100%);
  border: 2.5px solid #ffed4e;
  box-shadow: 0 0 8px #ffd700cc;
}
    .spell-bar {
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0 0 16px 0;
      flex-wrap: wrap;
      min-height: 52px;
      position: relative;
      z-index: 2;
      background: none;
    }
    .spell-btn {
      margin: 7px 11px 7px 0;
      padding: 10px 30px;
      background: #fff;
      color: #222;
      border: 2.5px solid #18e6e6;
      border-radius: 10px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1.15em;
      box-shadow: 0 0 4px #18e6e655;
      transition: background .13s, color .13s, border 0.12s;
      outline: none;
      letter-spacing: 1.2px;
      text-shadow: none;
      filter: none;
    }
    .spell-btn:disabled { background: #eee; color: #bbb; cursor: not-allowed; border:2.5px solid #bbb;}
    .spell-btn.selected { outline: 2px solid #ff0; background: #232b39; color:#18e6e6; border:2.5px solid #ff0;}
    .spell-info {
      font-size: 1em;
      color: #18e6e6;
      margin: 4px 0 0 0;
      text-align: center;
      min-height: 28px;
      font-family: inherit;
      font-weight: 600;
      letter-spacing: 1px;
    }
    .no-spells {
      color: #fc0;
      font-weight: bold;
      font-size: 1.12em;
      margin-right: 14px;
      text-shadow: none;
      font-family:inherit;
    }
    .shop-link-btn {
      background: #ff0;
      color: #232b39;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1em;
      box-shadow: none;
      padding: 8px 24px;
      margin-left: 14px;
      transition: background .13s, color .13s;
      outline: none;
      font-family:inherit;
    }
    .shop-link-btn:hover { background: #18e6e6; color:#222;}
    .fullscreen-panel {
      width: 100vw;
      height: 100vh;
      min-height: 100vh;
      min-width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #10131a;
      position: absolute;
      top: 0; left: 0;
      z-index: 1;
    }
    .panel-content {
      width: 100vw;
      max-width: 700px;
      margin: 0 auto;
      padding: 0 3vw;
      text-align: center;
      color: #fff;
      margin-top: 4vh;
      margin-bottom: 4vh;
      z-index: 2;
      background: #181f2a;
      border-radius:20px;
      box-shadow: 0 0 36px #0003;
      border: 1.5px solid #232b39;
    }
    h1, h2 { color: #18e6e6; text-shadow: 0 0 7px #fff2; font-family: 'Orbitron', Arial, sans-serif; }
    .coin {
      color: #18e6e6;
      font-weight: bold;
      text-shadow: none;
      font-size: 1.12em;
    }
    .menu-btn {
      width: 320px;
      max-width: 80vw;
      margin: 18px auto;
      padding: 18px 0;
      font-size: 1.3em;
      background: #fff;
      color: #18e6e6;
      border-radius: 10px;
      border: 2px solid #18e6e6;
      box-shadow: none;
      cursor: pointer;
      font-weight: bold;
      letter-spacing: 1px;
      transition: background .12s, color .12s;
      text-shadow: none;
      display:block;
      font-family:inherit;
    }
    .menu-btn:hover { background: #18e6e6; color: #fff;}
    .back-btn {
      padding: 13px 36px;
      margin-top: 32px;
      background: #232b39;
      color: #fff;
      border: 2px solid #18e6e6;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1.1em;
      font-weight: bold;
      box-shadow: none;
      transition: background .14s, color .14s;
      font-family:inherit;
    }
    .back-btn:hover { background: #18e6e6; color: #222; }
    .shop-spell {
      border: 1.5px solid #18e6e6;
      border-radius: 10px;
      padding: 17px 6px 17px 12px;
      margin: 13px 2px;
      background: #181f2a;
      text-align: left;
      font-size: 1.08em;
      box-shadow: none;
      max-width: 530px;
      margin-left:auto;
      margin-right:auto;
      font-family:inherit;
      transition: background .12s, border .12s;
    }
    .shop-spell.owned { background: #e7ffe7; border-color:#bcb;}
    .shop-spell .spell-title { font-weight: bold; font-size: 1.12em; color:#18e6e6;}
    .shop-spell .spell-desc { font-size: 1em; color: #bff; white-space: pre-line; }
    .shop-spell .spell-cost { color: #18e6e6; font-weight: bold; }
    .shop-spell button {
      margin-top: 7px;
      background: #18e6e6;
      color: #fff; border: none; border-radius: 7px;
      padding: 8px 20px; cursor: pointer;
      font-weight: bold;
      float: right;
      font-size:1em;
      box-shadow: none;
      transition: background .13s, color .13s;
      font-family:inherit;
    }
    .shop-spell button:disabled { background: #bbb; color:#eee; cursor: not-allowed; }
    .difficulty-select {
      margin-top: 24px;
      font-size: 1.12em;
      padding: 10px 24px;
      border-radius: 9px;
      border: 1.5px solid #18e6e6;
      background: #fff;
      color:#18e6e6;
      text-align:center;
      font-family:inherit;
    }
    .overlay {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      background: #000a;
      z-index: 1000;
      display: flex;
      align-items: center; justify-content: center;
    }
    .overlay-inner {
      background: #fff;
      color: #181f2a;
      padding: 44px 36px 34px 36px;
      border-radius: 22px;
      min-width: 320px;
      box-shadow: 0 10px 60px #0003;
      text-align: center;
      font-size: 2em;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      font-family:inherit;
      border: 2.5px solid #18e6e6;
    }
    .overlay-inner .small {
      font-size: 1.08em;
      margin-top: 30px;
      color: #18e6e6;
    }
    @media (max-width: 800px) {
      .board { max-width: 97vw; max-height: 97vw; }
      .panel-content { max-width: 95vw;}
      .shop-spell { max-width: 96vw;}
    }
    @media (max-width: 600px) {
      .board { max-width: 99vw; max-height: 99vw; }
      .panel-content { max-width: 99vw;}
      .shop-spell { max-width: 99vw;}
      .board-cell { font-size: 0.7em; }
      .spell-btn { font-size: 0.7em; padding: 7px 10px;}
      .moves-counter { font-size: 1.1em;}
      .info-bar { font-size: 0.9em; gap: 16px;}
    }

    /* --- Intro and crazy animation --- */
    .intro-logo {
      font-size: 3.4em;
      letter-spacing: 0.14em;
      margin-bottom: 16px;
      color: #18e6e6;
      text-shadow: 
        0 1px 0 #fff5,
        0 0 20px #0ff6,
        0 0 34px #44f8,
        0 0 2px #fff;
      animation: logoPop 1.2s cubic-bezier(.65,2,.22,.99);
    }
    @keyframes logoPop {
      0% { transform: scale(0.6) rotateY(60deg) skewX(10deg); opacity: 0;}
      40% { transform: scale(1.2) rotateY(-18deg); opacity: 1;}
      70% { transform: scale(1) rotateY(5deg);}
      100% { transform: scale(1) rotateY(0);}
    }
    .intro-desc {
      font-size: 1.2em;
      max-width: 540px;
      margin: 0 auto 42px auto;
      color: #bff;
      text-shadow: 0 1px 0 #fff3, 0 0 10px #0ff4;
      animation: fadeinDesc 1.5s cubic-bezier(.46,2.1,.34,.98);
    }
    @keyframes fadeinDesc {
      0% { opacity: 0; transform: translateY(42px);}
      70% { opacity: 1; transform: translateY(-7px);}
      100% { opacity: 1; transform: translateY(0);}
    }
    .intro-btns {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 48px;
      gap: 13px;
      animation: btnsPop 1.7s cubic-bezier(.53,2,.44,.98);
    }
    @keyframes btnsPop {
      0% { opacity: 0; transform: scale(0.7);}
      60% { opacity: 1; transform: scale(1.12);}
      100% { opacity: 1; transform: scale(1);}
    }
    .intro-splash {
      width: 100vw;
      height: 100vh;
      min-height: 100vh;
      min-width: 100vw;
      background: radial-gradient(ellipse at 60% 50%, #232b39 0%, #10131a 100%);
      position: absolute;
      top: 0; left: 0;
      z-index: 5000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      animation: introBg 1.6s cubic-bezier(.53,2,.44,.98);
    }
    @keyframes introBg {
      0% { opacity: 0.2;}
      80% { opacity: 1;}
      100% { opacity: 1;}
    }
    .intro-credits {
      color: #0ff;
      margin-top: 50px;
      font-size: 1.1em;
      opacity: 0.7;
      letter-spacing: 1.4px;
    }
    
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
    let coins = 0;
    let spellsOwned = [];
    let difficulty = 0;
    let screen = "intro";
    let gameState = null;
    let overlay = null;
    
    
    const SPELLS = [
      {
        key: "quantum",
        name: "Quantum Split",
        desc: `A single move, many futures.\nSplits a piece into 2-3 possible states; opponent sees all, but only one is real—revealed when targeted.`,
        cost: 30,
        mana: 20
      },
      {
        key: "collapse",
        name: "Waveform Collapse",
        desc: `Everything becomes... definite.\nCollapses all superpositioned pieces on the board to their actual states. Good for revealing enemy tricks or final strikes.`,
        cost: 20,
        mana: 50
      },
      {
        key: "fireball",
        name: "Fireball",
        desc: `Casts a fireball in a 4x4 area, flipping all squares inside.`,
        cost: 18,
        mana: 40
      },
      {
        key: "skip",
        name: "Skip",
        desc: `Skips the opponent's move, giving you two in a row.`,
        cost: 25,
        mana: 35
      },
      {
  key: "booster",
  name: "Boost Tile",
  desc: `Places a permanent boost tile that gives +5 mana per turn.\nLasts until enemy flips it.`,
  cost: 35,
  mana: 60
}
    ];
    let aiSpellsOwned = SPELLS.map(s => s.key);
    const DIFFICULTY_LEVELS = ["Easy", "Medium", "Hard", "Extreme"];
    const BOARD_SIZE = 10, INIT_MANA = 100, MANA_REGEN = 8, MAX_MOVES = 70;
    const RANDOM_EVENTS = [
      {
        name: "Flip Random Row",
        run(gs) {
          const row = Math.floor(Math.random() * BOARD_SIZE);
          for (let c = 0; c < BOARD_SIZE; c++)
            flip(gs.board, row, c, Math.random() < 0.5 ? 0 : 1);
          showOverlay(`Random Event: A mysterious force flips all of row ${row+1}!`);
        }
      },
      {
        name: "Flip Random Column",
        run(gs) {
          const col = Math.floor(Math.random() * BOARD_SIZE);
          for (let r = 0; r < BOARD_SIZE; r++)
            flip(gs.board, r, col, Math.random() < 0.5 ? 0 : 1);
          showOverlay(`Random Event: Lightning strikes column ${col+1} and flips it!`);
        }
      },
      {
        name: "Color Surge",
        run(gs) {
          for(let i=0;i<6;i++) {
            let r = Math.floor(Math.random()*BOARD_SIZE);
            let c = Math.floor(Math.random()*BOARD_SIZE);
            gs.board[r][c] = Math.random()<0.5?0:1;
          }
          showOverlay("Random Event: Color Surge! 6 random tiles have shifted color.");
        }
      },
      {
        name: "Mana Burst",
        run(gs) {
          gs.mana += 15;
          gs.aiMana += 15;
          showOverlay("Random Event: Mana Burst! Both players gain 15 mana.");
        }
      },
      {
        name: "Quantum Storm",
        run(gs) {
          for(let i=0;i<4;i++) {
            let r = Math.floor(Math.random()*BOARD_SIZE);
            let c = Math.floor(Math.random()*BOARD_SIZE/2) + BOARD_SIZE/2;
            if (gs.board[r][c] === 1) {
              let states = [0,1];
              if (Math.random()<0.5) states.push(1);
              const trueState = states[Math.floor(Math.random()*states.length)];
              gs.board[r][c] = {quantum:true,states,trueState,visible:false};
            }
          }
          showOverlay("Random Event: Quantum Storm! Some AI squares split into quantum states.");
        }
      }
    ];

    // --- INTRO SPLASH ---
    function renderIntro() {
      const panel = document.createElement('div');
      panel.className = "intro-splash";
      panel.innerHTML = `
        <div class="intro-logo">QUANTUM FLIP</div>
        <div class="intro-desc">
          <b>Flip, cast, and outwit the AI in this 3D-animated quantum puzzle-battle!</b><br>
          <span style="color:#fff;">Unleash spells, split reality, and claim every tile.<br>
          <span style="color:#18e6e6;">One move, infinite futures.</span>
        </div>
        <div class="intro-btns">
          <button class="menu-btn" onclick="screen='menu';render();">Enter Game</button>
        </div>
        <div class="intro-credits">by <b>skibiditoile3qb</b> | vanilla JS | 2025</div>
      `;
      return panel;
    }

    function render() {
      const root = document.getElementById('root');
      root.innerHTML = '';
      if (screen === "intro") {
        root.appendChild(renderIntro());
        return;
      }
      if (screen === "play") {
        root.appendChild(renderPlay());
      } else if (screen === "menu") {
        root.appendChild(renderMenu());
      } else if (screen === "settings") {
        root.appendChild(renderSettings());
      } else if (screen === "shop") {
        root.appendChild(renderShop());
      } else if (screen === "tutorial") {
        root.appendChild(renderTutorial());
      }
      if (overlay) root.appendChild(renderOverlay(...overlay));
    }
    function renderMenu() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.innerHTML = `
        <h1>Quantum Flip</h1>
        <div style="margin:16px 0 40px 0;">
          <span class="coin" style="font-size:2.2em;">Coins: ${coins} 🪙</span>
        </div>
      `;
      content.appendChild(menuBtn("Play", ()=>startGame()));
      content.appendChild(menuBtn("Tutorial", ()=>{screen="tutorial"; render();}));
      content.appendChild(menuBtn("Shop", ()=>{screen="shop"; render();}));
      content.appendChild(menuBtn("Settings", ()=>{screen="settings"; render();}));
      const by = document.createElement('div');
      by.style.marginTop = "53px";
      by.style.fontSize = "1.1em";
      by.style.color = "#0ff";
      by.innerHTML = 'by <b>skibiditoile3qb</b> | neon vanilla JS demo';
      content.appendChild(by);
      panel.appendChild(content);
      return panel;
    }
    function menuBtn(text, cb) {
      const btn = document.createElement('button');
      btn.className = "menu-btn";
      btn.innerText = text;
      btn.onclick = cb;
      return btn;
    }
    function renderSettings() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.innerHTML = `<h2>Settings</h2>
        <div style="margin-bottom:24px">
          <b>AI Difficulty:</b>
          <br>
          <select class="difficulty-select" id="diffsel">
            ${DIFFICULTY_LEVELS.map((d,i)=>`<option value="${i}"${i==difficulty?' selected':''}>${d}</option>`).join('')}
          </select>
        </div>
      `;
      setTimeout(()=>{
        document.getElementById('diffsel').onchange = e=>{
          difficulty = +e.target.value;
        };
      },10);
      content.appendChild(backBtn());
      panel.appendChild(content);
      return panel;
    }
    function renderShop() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.innerHTML = `<div style="margin-bottom:14px;">
        <b>Coins:</b> <span class="coin">${coins} 🪙</span>
      </div>
      <h2>Shop</h2>`;
      SPELLS.forEach(spell=>{
        const owned = spellsOwned.includes(spell.key);
        const spellDiv = document.createElement('div');
        spellDiv.className = 'shop-spell'+(owned?' owned':'');
        spellDiv.innerHTML = `
          <div class="spell-title">${spell.name}</div>
          <div class="spell-desc">${spell.desc}</div>
          <div>
            <span class="spell-cost">${spell.cost} 🪙</span>
            <span style="margin-left:12px; color:#0ff;">Use: ${spell.mana} mana</span>
          </div>
        `;
        const btn = document.createElement('button');
        btn.innerText = owned ? "Owned" : "Buy";
        btn.disabled = owned || coins < spell.cost;
        btn.onclick = ()=>{
          if (owned || coins < spell.cost) return;
          coins -= spell.cost;
          spellsOwned.push(spell.key);
          render();
        };
        spellDiv.appendChild(btn);
        content.appendChild(spellDiv);
      });
      content.appendChild(backBtn());
      panel.appendChild(content);
      return panel;
    }
    function renderTutorial() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.style.textAlign = "left";
      content.style.maxWidth = "650px";
      content.innerHTML = `
        <h2>Tutorial</h2>
        <ol>
          <li><b>The Goal:</b> Flip as many tiles to your color (white-neon) as possible before 70-move countdown ends.</li>
          <li><b>Turns:</b> You and the AI take turns. Each turn, click any <b>AI (aqua)</b> square; it and all adjacent squares (not corners) flip.</li>
          <li><b>Mana:</b> Each turn you regain 8 mana. Spells cost mana to cast.</li>
          <li><b>Spells:</b> Buy spells in the Shop, then select a spell in-game to use its effect!</li>
          <li><b>End:</b> When moves run out, whoever has more squares of their color wins and gets 10 coins!</li>
          <li><b>AI:</b> The higher the difficulty, the smarter the AI's moves. AI/Player cannot repeat the other's last move.</li>
          <li><b>Random Events:</b> Every 5 moves, a random event may occur!</li>
        </ol>
      `;
      content.appendChild(backBtn());
      panel.appendChild(content);
      return panel;
    }
    function backBtn() {
      const btn = document.createElement('button');
      btn.className = "back-btn";
      btn.innerText = "Back";
      btn.onclick = ()=>{screen="menu"; render();};
      return btn;
    }
 function renderPlay() {
  const gs = gameState;
  const main = document.createElement('div');
  main.style.minHeight = "100vh";
  main.style.display = "flex";
  main.style.flexDirection = "column";
  main.style.alignItems = "stretch";
  main.style.justifyContent = "flex-start";
  const topbar = document.createElement('div');
  topbar.className = "topbar";
  topbar.innerHTML = `
    <div class="moves-counter"><b>Moves Left: ${gs.movesLeft}</b></div>
    <div class="info-bar">
      <span><b>Mana:</b> ${gs.mana} <span style="color:#18e6e6;">💠</span></span>
      <span><b>AI Mana:</b> ${gs.aiMana} <span style="color:#0ff;">💠</span></span>
      <span><b>Your:</b> ${countBoard(gs.board,0)} <span style="color:#fff;">⬜</span></span>
      <span><b>AI:</b> ${countBoard(gs.board,1)} <span style="color:#18e6e6;">⬛</span></span>
    </div>`;
  main.appendChild(topbar);
  const gameMain = document.createElement('div');
  gameMain.className = "game-main";
  const boardWrap = document.createElement('div');
  boardWrap.className = 'board-wrap';
  const boardDiv = document.createElement('div');
  boardDiv.className = "board";

  // Show last move of the opponent only
  let lastMove = (gs.turn === 0) ? gs.lastAIMove : gs.lastPlayerMove;

for (let r = 0; r < BOARD_SIZE; r++) {
  for (let c = 0; c < BOARD_SIZE; c++) {
    const cell = gs.board[r][c];
    const cellDiv = document.createElement('div');
    cellDiv.className = "board-cell";
    const cellInner = document.createElement('div');
    cellInner.className = 'board-cell-inner';

    if (cell === 0) {
      cellDiv.classList.add("player");
    } else if (cell === 1) {
      cellDiv.classList.add("ai");
    } else if (typeof cell === 'object' && cell.type === 'mana') {
      cellDiv.classList.add("mana-tile");
      cellInner.innerHTML = '<span style="font-size:1.3em;">💧</span>';
    } else if (typeof cell === 'object' && cell.quantum) {
      cellDiv.classList.add("quantum");
      } else if (typeof cell === 'object' && cell.type === 'boost') {
  cellDiv.classList.add("boost-tile");
  cellInner.innerHTML = '<span style="font-size:1.3em;">⚡</span>';
      
      if (cell.visible) cellDiv.classList.add("visible");
   
  cellInner.innerHTML = `<span style="position:absolute;left:2px;top:2px;font-size:1.1em;color:#fff;text-shadow:0 0 10px #44f;font-weight:bold;">Q</span>`;
    } 

    if (lastMove && lastMove.r === r && lastMove.c === c) {
      cellDiv.classList.add("last-move");
    }

    cellDiv.onclick = () => handleCellClick(r, c);

    cellDiv.appendChild(cellInner);

    if (gs.turn === 0 && gs.lastAIMove && gs.lastAIMove.r === r && gs.lastAIMove.c === c) {
      cellDiv.style.opacity = 0.45;
      cellDiv.title = "Can't play in the same spot as the AI's last move!";
    }
    if (gs.turn === 1 && gs.lastPlayerMove && gs.lastPlayerMove.r === r && gs.lastPlayerMove.c === c) {
      cellDiv.style.opacity = 0.45;
      cellDiv.title = "Can't play in the same spot as the player's last move!";
    }
    boardDiv.appendChild(cellDiv);
  }
}
  boardWrap.appendChild(boardDiv);
  gameMain.appendChild(boardWrap);

  const spellsDiv = document.createElement('div');
  spellsDiv.className = 'spell-bar';
  if (spellsOwned.length === 0) {
    const msg = document.createElement('span');
    msg.className = "no-spells";
    msg.innerText = "No spells owned!";
    const shopBtn = document.createElement('button');
    shopBtn.className = "shop-link-btn";
    shopBtn.innerText = "Go to Shop";
    shopBtn.onclick = ()=>{screen="shop"; render();}
    spellsDiv.appendChild(msg);
    spellsDiv.appendChild(shopBtn);
  } else {
    SPELLS.forEach(spell=>{
      const owned = spellsOwned.includes(spell.key);
      const btn = document.createElement('button');
      btn.innerText = spell.name;
      btn.className = "spell-btn"+(gs.spellOn===spell.key?' selected':'');
      btn.disabled = !owned || gs.mana < spell.mana || (spell.key==="skip" && gs.usedSkip);
      btn.onclick = ()=>{
        if (!owned || gs.mana < spell.mana) return;
        if (spell.key==="collapse") { handleCollapseSpell(); return; }
        if (spell.key==="skip") { handleSkipSpell(); return; }
        gs.spellOn = spell.key;
        render();
      };
      spellsDiv.appendChild(btn);
    });
  }
  gameMain.appendChild(spellsDiv);
  const spellInfo = document.createElement('div');
  spellInfo.className = 'spell-info';
  spellInfo.innerText = "(Select a spell to use it on your next move.)";
  gameMain.appendChild(spellInfo);
  main.appendChild(gameMain);
  if (gs.winner && !overlay) showOverlay(gs.winner, () => { screen="menu"; overlay = null; render(); });
  return main;
}
   window.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.shiftKey && e.code === 'KeyC') { // Ctrl + Shift + C
    coins += 2000;
    console.log('💰 Dev Coins Added: 2000 (Total:', coins, ')');
  }
});
 function countBoard(board, val) {
  let n=0;
  for (let r=0;r<BOARD_SIZE;r++)
    for (let c=0;c<BOARD_SIZE;c++)
     if (
  board[r][c] === val ||
  (board[r][c]?.quantum && board[r][c]?.visible && board[r][c]?.trueState === val) ||
  (board[r][c]?.type === 'mana' && board[r][c]?.owner === val)
) n++;
  return n;
}

    function startGame() {
  let board = Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(1));
  for (let r=0;r<BOARD_SIZE;r++) for (let c=0;c<BOARD_SIZE;c++) 
    if (c<BOARD_SIZE/2) board[r][c]=0; // left half player, right half AI

  // --- Add 5 random mana tiles ---
  for (let i = 0; i < 5; i++) {
    let mr = Math.floor(Math.random() * BOARD_SIZE);
    let mc = Math.floor(Math.random() * BOARD_SIZE);
    if (typeof board[mr][mc] !== 'object') {
      board[mr][mc] = { type: 'mana', owner: board[mr][mc] };
    }
  }

  gameState = {
    board,
    mana: INIT_MANA,
    aiMana: INIT_MANA,
    turn: 0,
    movesLeft: MAX_MOVES,
    winner: null,
    skip: false,
    quantumPieces: [],
    spellOn: null,
    skipNextAI: false,
    usedSkip: false,
    lastPlayerMove: null,
    lastAIMove: null,
    movesPlayed: 0
  };
  screen = "play";
  render();
}

    function handleCellClick(r,c) {
      const gs = gameState;
      for (let br = 0; br < BOARD_SIZE; br++) {
  for (let bc = 0; bc < BOARD_SIZE; bc++) {
    if (typeof gs.board[br][bc] === 'object' && gs.board[br][bc].type === 'boost') {
      if (gs.board[br][bc].owner === 0 && gs.turn === 0) {
        gs.mana += 5; // Player gets boost
      } else if (gs.board[br][bc].owner === 1 && gs.turn === 1) {
        gs.aiMana += 5; // AI gets boost
      }
    }
  }
}
      if (gs.winner||gs.turn!==0) return;
      if (gs.lastAIMove && gs.lastAIMove.r===r && gs.lastAIMove.c===c) return;
let cell = gs.board[r][c];
if (cell && typeof cell==='object' && cell.quantum) {
  if (!cell.visible) return;
  cell = cell.trueState; // Use trueState, not states[0]
}
if (cell === null || cell === undefined) return;
// --- Mana tile logic ---
if (typeof gs.board[r][c] === 'object' && gs.board[r][c].type === 'mana' && gs.board[r][c].owner === 1) {
  gs.mana += 15; // Bigger boost
  gs.board[r][c] = 0; // convert to player tile
  gs.movesLeft--;
  gs.turn = 1;
  gs.lastPlayerMove = {r, c};
  gs.movesPlayed++;
  checkRandomEvent(gs);
  render(); // This will re-render and remove the mana icon
  setTimeout(()=>aiMove(gs),900);
  return;
}

if (cell!==1) return;
      if (gs.spellOn) {
        const spellKey = gs.spellOn;
        if (!spellsOwned.includes(spellKey)) return;
       if (spellKey==="quantum") {
  // Apply quantum to 3x3 area
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      let nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
        // Only quantumize AI tiles
        if (gs.board[nr][nc] === 1) {
          let states = [0, 1];
          if (Math.random() < 0.5) states.push(1);
          const trueState = states[Math.floor(Math.random() * states.length)];
          gs.board[nr][nc] = {quantum: true, states, trueState, visible: false};
          gs.quantumPieces.push({r: nr, c: nc});
        }
      }
    }
  }
  gs.mana -= SPELLS.find(s=>s.key===spellKey).mana;
  gs.spellOn = null;
  gs.movesLeft--;
  gs.turn = 1;
  gs.lastPlayerMove = {r,c};
  gs.movesPlayed++;
  checkRandomEvent(gs);
  render();
  setTimeout(()=>aiMove(gs),900);
  return;
}
        if (spellKey==="fireball") {
          for (let dr=0;dr<4;dr++) for (let dc=0;dc<4;dc++) {
            let nr=r+dr-1, nc=c+dc-1;
            if (nr>=0&&nr<BOARD_SIZE&&nc>=0&&nc<BOARD_SIZE) {
              if (typeof gs.board[nr][nc]==='object'&&gs.board[nr][nc].quantum) gs.board[nr][nc]=gs.board[nr][nc].trueState;
              else gs.board[nr][nc]=0;
            }
          }
          gs.mana -= SPELLS.find(s=>s.key===spellKey).mana;
          gs.spellOn = null;
          gs.movesLeft--;
          gs.turn = 1;
          gs.lastPlayerMove = {r,c};
          gs.movesPlayed++;
          checkRandomEvent(gs);
          render();
          setTimeout(()=>aiMove(gs),900);
          return;
        }
        if (spellKey==="booster") {
  gs.board[r][c] = {type: 'boost', owner: 0}; // Player-owned boost tile
  gs.mana -= SPELLS.find(s=>s.key===spellKey).mana;
  gs.spellOn = null;
  gs.movesLeft--;
  gs.turn = 1;
  gs.lastPlayerMove = {r,c};
  gs.movesPlayed++;
  checkRandomEvent(gs);
  render();
  setTimeout(()=>aiMove(gs),900);
  return;
}
      }
      flip(gs.board, r, c, 0);
      gs.movesLeft--;
      gs.turn = 1;
      gs.mana += MANA_REGEN;
      gs.lastPlayerMove = {r,c};
      gs.movesPlayed++;
      checkRandomEvent(gs);
      if (gs.movesLeft<=0) {
        const w = countBoard(gs.board,0), bl = countBoard(gs.board,1);
        endGame(w>bl?1:w<bl?0:null);
        return;
      }
      render();
      setTimeout(()=>aiMove(gs),900);
    }
function flip(board, r, c, color, simulate = false) {
  const dirs = [[0,0],[-1,0],[1,0],[0,-1],[0,1]];
  const flipCells = [];

  for (const [dr, dc] of dirs) {
    let nr = r + dr, nc = c + dc;
    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
      const oldCell = board[nr][nc];
      let oldColor;

 if (oldCell && typeof oldCell === 'object' && oldCell.quantum) {
        oldColor = oldCell.trueState;
} else if (oldCell && typeof oldCell === 'object' && oldCell.type === 'mana') {
        oldColor = oldCell.owner;
      } else {
        oldColor = oldCell;
      }

      const newColor = 1 - oldColor;

      if (typeof oldCell === 'object' && oldCell.type === 'mana') {
        board[nr][nc] = newColor; // Remove mana status when flipped
      } else {
        board[nr][nc] = newColor;
      }

      flipCells.push({ r: nr, c: nc, oldColor, newColor });
    }
  }

  if (simulate) return; // ✅ now safely inside the function

  // Trigger 3D flip animations with cascade
  flipCells.forEach((cell, i) => {
    setTimeout(() => {
      const cellEl = document.querySelector(
        `.board-cell:nth-child(${cell.r * BOARD_SIZE + cell.c + 1}) .board-cell-inner`
      );
      if (cellEl) {
        cellEl.style.background = "#10131a";
        cellEl.style.setProperty('--start-color', "#10131a");
        cellEl.style.setProperty('--end-color', cell.newColor === 0 ? '#fff' : '#07090d');
        cellEl.style.animation = 'flip3d 0.3s ease-out, flipColor 0.3s ease-out';

        setTimeout(() => {
          cellEl.style.background = cell.newColor === 0 ? '#fff' : '#07090d';
          cellEl.style.animation = '';
        }, 300);
      }
    }, i * 50);
  });
}

    function handleCollapseSpell() {
      const gs = gameState;
      if (!spellsOwned.includes("collapse")||gs.mana<SPELLS.find(s=>s.key==="collapse").mana) return;
      for (let r=0;r<BOARD_SIZE;r++) for (let c=0;c<BOARD_SIZE;c++)
        if (typeof gs.board[r][c]==='object'&&gs.board[r][c].quantum) gs.board[r][c]=gs.board[r][c].trueState;
      gs.mana -= SPELLS.find(s=>s.key==="collapse").mana;
      gs.spellOn = null;
      gs.movesLeft--;
      gs.turn = 1;
      gs.movesPlayed++;
      checkRandomEvent(gs);
      render();
      setTimeout(()=>aiMove(gs),900);
    }
   function handleSkipSpell() {
  const gs = gameState;
  if (!spellsOwned.includes("skip")||gs.mana<SPELLS.find(s=>s.key==="skip").mana||gs.usedSkip) return;
  gs.mana -= SPELLS.find(s=>s.key==="skip").mana;
  gs.skipNextAI = true; // Skip AI's next turn
  gs.usedSkip = true;
  gs.spellOn = null;
  gs.movesLeft--;
  gs.turn = 0; // Stay player's turn
  gs.movesPlayed++;
  checkRandomEvent(gs);
  render();
}
    function endGame(playerWon) {
      const gs = gameState;
      gs.winner = playerWon ? "You win! +10 coins" : playerWon===null ? "Draw!" : "AI wins!";
      if (playerWon) coins += 10;
      overlay = [gs.winner, () => { screen="menu"; overlay = null; render(); }];
      render();
    }
    function aiMove(gs) {
      
  if (gs.winner) return;

  if (gs.skipNextAI) { 
    gs.skipNextAI = false; 
    gs.turn = 0; // Back to player
    render(); 
    return; 
  }
      for (let br = 0; br < BOARD_SIZE; br++) {
  for (let bc = 0; bc < BOARD_SIZE; bc++) {
    if (typeof gs.board[br][bc] === 'object' && gs.board[br][bc].type === 'boost') {
      if (gs.board[br][bc].owner === 0 && gs.turn === 0) {
        gs.mana += 5; // Player gets boost
      } else if (gs.board[br][bc].owner === 1 && gs.turn === 1) {
        gs.aiMana += 5; // AI gets boost
      }
    }
  }
}
  if (gs.skip) { gs.skip=false; gs.turn=0; gs.usedSkip=true; gs.movesPlayed++; checkRandomEvent(gs); render(); return; }
      let possibleSpells = SPELLS.filter(s => aiSpellsOwned.includes(s.key) && gs.aiMana >= s.mana);
if (possibleSpells.length > 0 && Math.random() < 0.33) { // 33% chance to cast a spell
  let spell = possibleSpells[Math.floor(Math.random() * possibleSpells.length)];
  if (spell.key === "collapse") {
    // Collapse all quantum pieces
    for (let r = 0; r < BOARD_SIZE; r++)
      for (let c = 0; c < BOARD_SIZE; c++)
        if (typeof gs.board[r][c] === 'object' && gs.board[r][c].quantum)
          gs.board[r][c] = gs.board[r][c].trueState;
    gs.aiMana -= spell.mana;
    gs.movesLeft--;
    gs.turn = 0;
    gs.lastAIMove = null;
    gs.movesPlayed++;
    checkRandomEvent(gs);
    render();
    setTimeout(render, 350);
    return;
  }
  if (spell.key === "skip") {
    // AI skips player's next turn
    gs.aiMana -= spell.mana;
    gs.skip = true;
    gs.usedSkip = true;
    gs.movesLeft--;
    gs.turn = 0;
    gs.lastAIMove = null;
    gs.movesPlayed++;
    checkRandomEvent(gs);
    render();
    setTimeout(render, 350);
    return;
  }
  if (spell.key === "fireball") {
    // Fireball: pick a random 4x4 area with at least one player tile
    
    let found = false;
    for (let tries = 0; tries < 10 && !found; tries++) {
      let r = Math.floor(Math.random() * (BOARD_SIZE - 3));
      let c = Math.floor(Math.random() * (BOARD_SIZE - 3));
      for (let dr = 0; dr < 4; dr++)
        for (let dc = 0; dc < 4; dc++)
          if (gs.board[r+dr][c+dc] === 0) found = true;
      if (found) {
        for (let dr = 0; dr < 4; dr++)
          for (let dc = 0; dc < 4; dc++) {
            let nr = r + dr, nc = c + dc;
            if (typeof gs.board[nr][nc] === 'object' && gs.board[nr][nc].quantum)
              gs.board[nr][nc] = gs.board[nr][nc].trueState;
            else
              gs.board[nr][nc] = 1;
          }
        gs.aiMana -= spell.mana;
        gs.movesLeft--;
        gs.turn = 0;
        gs.lastAIMove = {r: r+2, c: c+2}; // Center of fireball
        gs.movesPlayed++;
        checkRandomEvent(gs);
        render();
        setTimeout(render, 350);
        
        return;
      }
    }
  }
  // Quantum spell not used by AI for now (could add logic if you want)
}
  const moves=[];
for (let r=0; r<BOARD_SIZE; r++)
  for (let c=0; c<BOARD_SIZE; c++) {
    const cell = gs.board[r][c];
    // Null-safe: Only check properties if cell is not null
   let canMove = false;
if (cell === 0) canMove = true;
else if (cell && typeof cell === 'object' && cell.type === 'mana' && cell.owner === 0) canMove = true;
else if (cell && typeof cell === 'object' && cell.quantum && cell.visible && cell.trueState === 0) canMove = true;

if (canMove) {
      if (gs.lastPlayerMove && gs.lastPlayerMove.r === r && gs.lastPlayerMove.c === c) continue;
      const b2 = JSON.parse(JSON.stringify(gs.board));
      flip(b2, r, c, 1, true); // SIMULATE: no animation, just logical flip
      const gain = countBoard(b2, 1) - countBoard(gs.board, 1);
      moves.push({ r, c, gain, b2 });
    }
  }
  let move = null;
  if (moves.length === 0) { gs.turn = 0; render(); return; }
  let sortedMoves = [...moves].sort((a,b)=>b.gain-a.gain);
  if (difficulty === 0) {
    let top = sortedMoves.slice(0,25); move = top[Math.floor(Math.random() * top.length)];
  } else if (difficulty === 1) {
    let top = sortedMoves.slice(0,15); move = top[Math.floor(Math.random() * top.length)];
  } else if (difficulty === 2) {
    let top = sortedMoves.slice(0,3); move = top[Math.floor(Math.random() * top.length)];
  } else if (difficulty === 3) {
    let best = -Infinity;
    for (const m of sortedMoves.slice(0,6)) {
      let bestReply = -Infinity;
      for (let rr=0; rr<BOARD_SIZE; rr++) for (let cc=0; cc<BOARD_SIZE; cc++)
        if (m.b2[rr][cc] === 1) {
          if (m.r === rr && m.c === cc) continue;
          let b3 = JSON.parse(JSON.stringify(m.b2));
          flip(b3, rr, cc, 0, true); // SIMULATE
          let v = countBoard(b3,1) - countBoard(m.b2,1);
          if (v > bestReply) bestReply = v;
        }
      let value = m.gain - (bestReply || 0);
      if (value > best) { best = value; move = m; }
    }
  }
  if (!move) move = sortedMoves[0];
  if (!move) { gs.turn = 0; render(); return; }

  // Animate the real move only
  flip(gs.board, move.r, move.c, 1, false);

  // Reveal quantum pieces
  for (let r=0; r<BOARD_SIZE; r++)
    for (let c=0; c<BOARD_SIZE; c++)
      if (typeof gs.board[r][c] === 'object' && gs.board[r][c].quantum && !gs.board[r][c].visible)
        gs.board[r][c].visible = true;

  gs.movesLeft--;
  gs.aiMana += MANA_REGEN;
  gs.turn = 0;
  gs.lastAIMove = {r:move.r, c:move.c};
  gs.movesPlayed++;
  checkRandomEvent(gs);
  if (gs.movesLeft <= 0) {
    const w = countBoard(gs.board,0), bl = countBoard(gs.board,1);
    endGame(w > bl ? 1 : w < bl ? 0 : null);
    return;
  }
  setTimeout(render, 350); // Wait for animation before rendering board update
}
    function checkRandomEvent(gs) {
      if (!gs.winner && gs.movesPlayed > 0 && gs.movesPlayed % 5 === 0) {
        if (Math.random() < 0.5) {
          const event = RANDOM_EVENTS[Math.floor(Math.random()*RANDOM_EVENTS.length)];
          event.run(gs);
        }
      }
    }
    function showOverlay(msg, cb) {
      overlay=[msg, cb];
      render();
    }
    function renderOverlay(msg, cb) {
      const div = document.createElement('div');
      div.className = "overlay";
      div.onclick = ()=>{
        overlay=null;
        if (cb) cb();
        render();
      };
      div.innerHTML = `<div class="overlay-inner">${msg}<div class="small">(Click to continue)</div></div>`;
      return div;
    }
    window.onload = render;
  </script>
</body>
</html>
