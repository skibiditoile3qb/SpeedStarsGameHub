<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quantum Flip Game</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://fonts.googleapis.com/css?family=Orbitron:wght@800&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0; padding: 0;
      font-family: 'Orbitron', Arial, sans-serif;
      background: #05080e;
      min-height: 100vh;
      min-width: 100vw;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    #root {
      width: 100vw;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
      position: relative;
      z-index: 0;
    }
    /* Topbar */
    .topbar {
      width: 100vw;
      min-height: 90px;
      background: rgba(12, 18, 33, 0.92);
      box-shadow: 0 0 32px #0ff7, 0 0 4px #fff4;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      flex-direction: column;
      position: relative;
      z-index: 2;
      border-bottom: 3px solid #0ffb;
    }
    .moves-counter {
      font-family: 'Orbitron', monospace, Arial, sans-serif;
      font-size: 2.7em;
      color: #44fff7;
      text-shadow: 0 0 18px #44fff7, 0 0 5px #fff;
      background: rgba(18,35,40,0.70);
      padding: 9px 48px 2px 48px;
      border-radius: 0 0 48px 48px;
      margin: 0 auto 0 auto;
      position: absolute;
      left: 50%;
      top: 0;
      transform: translateX(-50%);
      border-bottom: 3.5px solid #0ff;
      box-shadow: 0 8px 32px #0ff7;
      pointer-events: none;
      animation: movePulse 2.1s infinite alternate;
    }
    @keyframes movePulse {
      0%   { filter: brightness(1) blur(0px);}
      100% { filter: brightness(1.14) blur(2px);}
    }
    .info-bar {
      width: 100vw;
      font-size: 1.2em;
      color: #0ff;
      text-shadow: 0 0 4px #0ff8;
      background: none;
      display: flex;
      justify-content: center;
      gap: 38px;
      align-items: center;
      margin: 0;
      padding: 17px 0 0 0;
      position: relative;
      z-index: 2;
      letter-spacing: 1.5px;
      font-weight: 900;
      font-family: 'Orbitron', Arial, sans-serif;
      filter: drop-shadow(0 0 11px #0ff8);
    }
    .game-main {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: 100vw;
      min-height: 0;
      background: linear-gradient(123deg, #181a25 54%, #0ff2 100%);
      position: relative;
      box-shadow: 0 0 180px #0ff3 inset, 0 0 90px #fff2 inset;
    }
    .board-wrap {
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 38px;
      margin-bottom: 18px;
      min-height: 0;
      z-index: 1;
    }
    .board {
      display: grid;
      grid-template-rows: repeat(10,1fr);
      grid-template-columns: repeat(10,1fr);
      gap: 10px;
      background: rgba(0,0,0,0.42);
      border-radius: 38px;
      box-shadow: 0 0 110px 35px #1eefff55, 0 0 130px 25px #ffffff18, 0 0 22px #0ff9;
      margin: 0 auto;
      width: min(70vw, 70vh);
      height: min(70vw, 70vh);
      max-width: 97vw;
      max-height: 97vw;
      aspect-ratio: 1/1;
      position: relative;
      border: 4px solid #fff8;
      transition: box-shadow 0.2s;
      animation: boardGlow 6s linear infinite alternate;
    }
    @keyframes boardGlow {
      0% { box-shadow: 0 0 70px 22px #0ff5, 0 0 20px #fff5; }
      100% { box-shadow: 0 0 130px 45px #0ff7, 0 0 35px #fff9; }
    }
    .board-cell {
      width: 100%;
      height: 100%;
      border-radius: 17px;
      border: 5px solid #191a22;
      box-sizing: border-box;
      font-size: 1.15em;
      cursor: pointer;
      background: #000;
      position: relative;
      user-select: none;
      box-shadow: 0 0 31px 11px #0ff8, 0 0 3px #fff4;
      overflow: hidden;
      z-index: 1;
      transition: box-shadow 0.18s, border 0.18s, background 0.18s, filter 0.18s;
      filter: brightness(1.08);
    }
    .board-cell.player {
      background: radial-gradient(circle at 52% 62%, #fff 67%, #d4eaff 100%, #2cf 170%);
      box-shadow: 0 0 52px 18px #fff, 0 0 22px #fff, 0 0 17px #0ff5;
      border: 4px solid #fff;
      animation: neonwhite 1.7s infinite alternate;
      filter: brightness(1.25) blur(0.4px);
      transition: filter 0.25s;
    }
    .board-cell.player:hover {
      filter: brightness(1.5) blur(0px);
      box-shadow: 0 0 70px 30px #fff, 0 0 22px #0ffb;
      border-color: #0ff;
    }
    @keyframes neonwhite {
      0% { box-shadow: 0 0 40px 18px #fff, 0 0 10px #fff9, 0 0 7px #0ff5; }
      100% { box-shadow: 0 0 78px 39px #fff, 0 0 30px #0ff9, 0 0 13px #0ff9; }
    }
    .board-cell.ai {
      background: radial-gradient(circle at 53% 60%, #000 60%, #00e0ff 100%, #00f 180%);
      box-shadow: 0 0 54px 27px #0ff, 0 0 22px #0ff, 0 0 32px #000;
      border: 4px solid #0ff;
      animation: neonaqua 1.5s infinite alternate;
      filter: brightness(1.1) blur(0.2px);
      transition: filter 0.2s;
    }
    .board-cell.ai:hover {
      filter: brightness(1.4) blur(0px);
      box-shadow: 0 0 80px 40px #0ff, 0 0 30px #fff;
      border-color: #fff;
    }
    @keyframes neonaqua {
      0% { box-shadow: 0 0 54px 27px #0ff, 0 0 22px #0ff, 0 0 12px #000;}
      100% { box-shadow: 0 0 90px 49px #0ff, 0 0 40px #0ff9, 0 0 38px #00f;}
    }
    .board-cell.quantum {
      background: repeating-linear-gradient(45deg, #3ff 0 5px, #fff 6px 14px);
      box-shadow: 0 0 36px #44f7,0 0 50px #4ff4;
      border-color:#44f;
      filter: saturate(1.8) brightness(1.22);
    }
    .board-cell.quantum.visible {
      background: linear-gradient(120deg,#0ff,#44f 60%);
      animation: none;
      filter: blur(0.7px) brightness(1.3);
    }
    .board-cell.last-move {
      outline: 5.5px solid #f00 !important;
      z-index: 2;
      box-shadow: 0 0 36px #f08a, 0 0 18px #fff9;
      filter: brightness(1.5) blur(0.1px) drop-shadow(0 0 14px #f00);
    }
    .board-cell:active {
      border-color: #ff0;
      box-shadow: 0 0 32px #ff0b;
    }
    .spell-bar {
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0 0 16px 0;
      flex-wrap: wrap;
      min-height: 62px;
      position: relative;
      z-index: 2;
      background: none;
    }
    .spell-btn {
      margin: 7px 11px 7px 0;
      padding: 14px 34px;
      background: linear-gradient(90deg,#fff 40%,#0ff 100%);
      color: #000;
      border: 3px solid #fff;
      border-radius: 15px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1.2em;
      box-shadow: 0 0 26px #0ff8, 0 0 8px #fff9;
      transition: background .13s, color .13s, border 0.18s, box-shadow 0.18s;
      outline: none;
      letter-spacing: 1.7px;
      text-shadow: 0 0 19px #fff;
      filter: brightness(1.1);
    }
    .spell-btn:disabled { background: #022; color: #066; cursor: not-allowed; border: 3px solid #0ff; filter: brightness(0.8);}
    .spell-btn.selected { outline: 3px solid #ff0; background: #222; color:#0ff; border:3px solid #ff0; filter: brightness(1.32);}
    .spell-info {
      font-size: 1.06em;
      color: #0ff;
      margin: 4px 0 0 0;
      text-align: center;
      text-shadow: 0 0 11px #0ff8;
      min-height: 28px;
      font-family: 'Orbitron', Arial, sans-serif;
      font-weight:600;
      letter-spacing: 1px;
    }
    .no-spells {
      color: #fc0;
      font-weight: bold;
      font-size: 1.15em;
      margin-right: 14px;
      text-shadow: 0 0 14px #fff;
      font-family:inherit;
    }
    .shop-link-btn {
      background: linear-gradient(90deg,#ff0 20%,#0ff 100%);
      color: #000;
      border: none;
      border-radius: 12px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1.08em;
      box-shadow: 0 0 19px #fff4;
      padding: 10px 30px;
      margin-left: 14px;
      transition: background .13s, color .13s;
      outline: none;
      font-family:inherit;
    }
    .shop-link-btn:hover { background: linear-gradient(90deg,#0ff 20%,#ff0 100%); }
    /* Panels, overlays, etc. */
    .fullscreen-panel {
      width: 100vw;
      height: 100vh;
      min-height: 100vh;
      min-width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(ellipse at 60% 50%, #0ff1 0%, #070a13 100%);
      position: absolute;
      top: 0; left: 0;
      z-index: 1;
    }
    .panel-content {
      width: 100vw;
      max-width: 700px;
      margin: 0 auto;
      padding: 0 3vw;
      text-align: center;
      color: #fff;
      margin-top: 4vh;
      margin-bottom: 4vh;
      z-index: 2;
      background:rgba(0,0,0,0.27);
      border-radius:30px;
      box-shadow: 0 0 60px #0ff3, 0 0 10px #fff2;
      border: 2px solid #0ffaa;
      animation: panelPulse 8s linear infinite alternate;
    }
    @keyframes panelPulse {
      0%   { box-shadow: 0 0 50px #0ff3, 0 0 10px #fff2; }
      100% { box-shadow: 0 0 120px #0ff7, 0 0 30px #fff9; }
    }
    h1, h2 { color: #0ff; text-shadow: 0 0 17px #0ff8; font-family: 'Orbitron', Arial, sans-serif; }
    .coin {
      color: #0ff;
      font-weight: bold;
      text-shadow: 0 0 8px #0ff, 0 0 5px #fff8;
      font-size: 1.25em;
    }
    .menu-btn {
      width: 320px;
      max-width: 80vw;
      margin: 18px auto;
      padding: 18px 0;
      font-size: 1.45em;
      background: linear-gradient(90deg, #0ff 30%, #88f 100%);
      color: #000;
      border-radius: 17px;
      border: none;
      box-shadow: 0 4px 22px #0ff7, 0 0 8px #fff4;
      cursor: pointer;
      font-weight: bold;
      letter-spacing: 1px;
      transition: background .16s, color .16s;
      text-shadow: 0 0 11px #fff8;
      display:block;
      font-family:inherit;
    }
    .menu-btn:hover { background: linear-gradient(90deg, #0cf 10%, #0ff 90%); color: #fff;}
    .back-btn {
      padding: 13px 36px;
      margin-top: 32px;
      background: #111;
      color: #0ff;
      border: 2px solid #0ff;
      border-radius: 17px;
      cursor: pointer;
      font-size: 1.2em;
      font-weight: bold;
      box-shadow: 0 0 20px #0ff7;
      transition: background .14s, color .14s;
      font-family:inherit;
    }
    .back-btn:hover { background: #0ff; color: #000; }
    .shop-spell {
      border: 2px solid #0ff6;
      border-radius: 17px;
      padding: 22px 6px 22px 12px;
      margin: 19px 2px;
      background: #051218;
      text-align: left;
      transition: background .22s, border .22s;
      position: relative;
      font-size: 1.18em;
      box-shadow: 0 0 24px #0ff3;
      max-width: 590px;
      margin-left:auto;
      margin-right:auto;
      font-family:inherit;
    }
    .shop-spell.owned { background: #022e1c; border-color:#0f06; }
    .shop-spell .spell-title { font-weight: bold; font-size: 1.2em; color:#0ff; text-shadow:0 0 7px #0ff9;}
    .shop-spell .spell-desc { font-size: 1em; color: #bff; white-space: pre-line; }
    .shop-spell .spell-cost { color: #0ff; font-weight: bold; }
    .shop-spell button {
      margin-top: 7px;
      background: #0ff;
      color: #000; border: none; border-radius: 10px;
      padding: 10px 30px; cursor: pointer;
      font-weight: bold;
      float: right;
      font-size:1.11em;
      box-shadow: 0 0 18px #0ff7;
      transition: background .15s, color .15s;
      font-family:inherit;
    }
    .shop-spell button:disabled { background: #099; color:#555; cursor: not-allowed; }
    .difficulty-select {
      margin-top: 38px;
      font-size: 1.2em;
      padding: 10px 24px;
      border-radius: 12px;
      border: 2px solid #0ff;
      background: #021e24;
      color:#0ff;
      text-align:center;
      font-family:inherit;
    }
    /* Overlay */
    .overlay {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      background: #000a;
      z-index: 1000;
      display: flex;
      align-items: center; justify-content: center;
    }
    .overlay-inner {
      background: #0ff;
      color: #111;
      padding: 60px 36px 40px 36px;
      border-radius: 22px;
      min-width: 320px;
      box-shadow: 0 10px 60px #0ffb;
      text-align: center;
      font-size: 2.2em;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      font-family:inherit;
    }
    .overlay-inner .small {
      font-size: 1.1em;
      margin-top: 30px;
      color: #099;
    }
    @media (max-width: 800px) {
      .board { max-width: 97vw; max-height: 97vw; }
      .panel-content { max-width: 95vw;}
      .shop-spell { max-width: 96vw;}
    }
    @media (max-width: 600px) {
      .board { max-width: 99vw; max-height: 99vw; }
      .panel-content { max-width: 99vw;}
      .shop-spell { max-width: 99vw;}
      .board-cell { font-size: 0.7em; }
      .spell-btn { font-size: 0.7em; padding: 7px 10px;}
      .moves-counter { font-size: 1.4em; padding: 6px 14px 2px 14px;}
      .info-bar { font-size: 0.9em; gap: 18px;}
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
    // --- Game State ---
    let coins = 0;
    let spellsOwned = [];
    let difficulty = 0; // 0=easy,1=med,2=hard,3=extreme
    let screen = "menu";
    let gameState = null;
    let overlay = null;

    const SPELLS = [
      {
        key: "quantum",
        name: "Quantum Split",
        desc: `A single move, many futures.\nSplits a piece into 2-3 possible states; opponent sees all, but only one is real—revealed when targeted.`,
        cost: 30,
        mana: 20
      },
      {
        key: "collapse",
        name: "Waveform Collapse",
        desc: `Everything becomes... definite.\nCollapses all superpositioned pieces on the board to their actual states. Good for revealing enemy tricks or final strikes.`,
        cost: 20,
        mana: 50
      },
      {
        key: "fireball",
        name: "Fireball",
        desc: `Casts a fireball in a 4x4 area, flipping all squares inside.`,
        cost: 18,
        mana: 40
      },
      {
        key: "skip",
        name: "Skip",
        desc: `Skips the opponent's move, giving you two in a row.`,
        cost: 25,
        mana: 35
      }
    ];
    const DIFFICULTY_LEVELS = ["Easy", "Medium", "Hard", "Extreme"];
    const BOARD_SIZE = 10, INIT_MANA = 100, MANA_REGEN = 8, MAX_MOVES = 70;

    // --- Random Events ---
    const RANDOM_EVENTS = [
      {
        name: "Flip Random Row",
        run(gs) {
          const row = Math.floor(Math.random() * BOARD_SIZE);
          for (let c = 0; c < BOARD_SIZE; c++)
            flip(gs.board, row, c, Math.random() < 0.5 ? 0 : 1);
          showOverlay(`Random Event: A mysterious force flips all of row ${row+1}!`);
        }
      },
      {
        name: "Flip Random Column",
        run(gs) {
          const col = Math.floor(Math.random() * BOARD_SIZE);
          for (let r = 0; r < BOARD_SIZE; r++)
            flip(gs.board, r, col, Math.random() < 0.5 ? 0 : 1);
          showOverlay(`Random Event: Lightning strikes column ${col+1} and flips it!`);
        }
      },
      {
        name: "Color Surge",
        run(gs) {
          for(let i=0;i<6;i++) {
            let r = Math.floor(Math.random()*BOARD_SIZE);
            let c = Math.floor(Math.random()*BOARD_SIZE);
            gs.board[r][c] = Math.random()<0.5?0:1;
          }
          showOverlay("Random Event: Color Surge! 6 random tiles have shifted color.");
        }
      },
      {
        name: "Mana Burst",
        run(gs) {
          gs.mana += 15;
          gs.aiMana += 15;
          showOverlay("Random Event: Mana Burst! Both players gain 15 mana.");
        }
      },
      {
        name: "Quantum Storm",
        run(gs) {
          for(let i=0;i<4;i++) {
            let r = Math.floor(Math.random()*BOARD_SIZE);
            let c = Math.floor(Math.random()*BOARD_SIZE/2) + BOARD_SIZE/2;
            if (gs.board[r][c] === 1) {
              let states = [0,1];
              if (Math.random()<0.5) states.push(1);
              const trueState = states[Math.floor(Math.random()*states.length)];
              gs.board[r][c] = {quantum:true,states,trueState,visible:false};
            }
          }
          showOverlay("Random Event: Quantum Storm! Some AI squares split into quantum states.");
        }
      }
    ];

    // ----------- Rendering -----------
    function render() {
      const root = document.getElementById('root');
      root.innerHTML = '';
      if (screen === "play") {
        root.appendChild(renderPlay());
      } else if (screen === "menu") {
        root.appendChild(renderMenu());
      } else if (screen === "settings") {
        root.appendChild(renderSettings());
      } else if (screen === "shop") {
        root.appendChild(renderShop());
      } else if (screen === "tutorial") {
        root.appendChild(renderTutorial());
      }
      if (overlay) root.appendChild(renderOverlay(...overlay));
    }
    function renderMenu() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.innerHTML = `
        <h1>Quantum Flip</h1>
        <div style="margin:16px 0 40px 0;">
          <span class="coin" style="font-size:2.2em;">Coins: ${coins} 🪙</span>
        </div>
      `;
      content.appendChild(menuBtn("Play", ()=>startGame()));
      content.appendChild(menuBtn("Tutorial", ()=>{screen="tutorial"; render();}));
      content.appendChild(menuBtn("Shop", ()=>{screen="shop"; render();}));
      content.appendChild(menuBtn("Settings", ()=>{screen="settings"; render();}));
      const by = document.createElement('div');
      by.style.marginTop = "53px";
      by.style.fontSize = "1.1em";
      by.style.color = "#0ff";
      by.innerHTML = 'by <b>skibiditoile3qb</b> | neon vanilla JS demo';
      content.appendChild(by);
      panel.appendChild(content);
      return panel;
    }
    function menuBtn(text, cb) {
      const btn = document.createElement('button');
      btn.className = "menu-btn";
      btn.innerText = text;
      btn.onclick = cb;
      return btn;
    }
    function renderSettings() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.innerHTML = `<h2>Settings</h2>
        <div style="margin-bottom:24px">
          <b>AI Difficulty:</b>
          <br>
          <select class="difficulty-select" id="diffsel">
            ${DIFFICULTY_LEVELS.map((d,i)=>`<option value="${i}"${i==difficulty?' selected':''}>${d}</option>`).join('')}
          </select>
        </div>
      `;
      setTimeout(()=>{
        document.getElementById('diffsel').onchange = e=>{
          difficulty = +e.target.value;
        };
      },10);
      content.appendChild(backBtn());
      panel.appendChild(content);
      return panel;
    }
    function renderShop() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.innerHTML = `<div style="margin-bottom:14px;">
        <b>Coins:</b> <span class="coin">${coins} 🪙</span>
      </div>
      <h2>Shop</h2>`;
      SPELLS.forEach(spell=>{
        const owned = spellsOwned.includes(spell.key);
        const spellDiv = document.createElement('div');
        spellDiv.className = 'shop-spell'+(owned?' owned':'');
        spellDiv.innerHTML = `
          <div class="spell-title">${spell.name}</div>
          <div class="spell-desc">${spell.desc}</div>
          <div>
            <span class="spell-cost">${spell.cost} 🪙</span>
            <span style="margin-left:12px; color:#0ff;">Use: ${spell.mana} mana</span>
          </div>
        `;
        const btn = document.createElement('button');
        btn.innerText = owned ? "Owned" : "Buy";
        btn.disabled = owned || coins < spell.cost;
        btn.onclick = ()=>{
          if (owned || coins < spell.cost) return;
          coins -= spell.cost;
          spellsOwned.push(spell.key);
          render();
        };
        spellDiv.appendChild(btn);
        content.appendChild(spellDiv);
      });
      content.appendChild(backBtn());
      panel.appendChild(content);
      return panel;
    }
    function renderTutorial() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.style.textAlign = "left";
      content.style.maxWidth = "650px";
      content.innerHTML = `
        <h2>Tutorial</h2>
        <ol>
          <li><b>The Goal:</b> Flip as many tiles to your color (white-neon) as possible before 70-move countdown ends.</li>
          <li><b>Turns:</b> You and the AI take turns. Each turn, click any <b>AI (aqua)</b> square; it and all adjacent squares (not corners) flip.</li>
          <li><b>Mana:</b> Each turn you regain 8 mana. Spells cost mana to cast.</li>
          <li><b>Spells:</b> Buy spells in the Shop, then select a spell in-game to use its effect!</li>
          <li><b>End:</b> When moves run out, whoever has more squares of their color wins and gets 10 coins!</li>
          <li><b>AI:</b> The higher the difficulty, the smarter the AI's moves. AI/Player cannot repeat the other's last move.</li>
          <li><b>Random Events:</b> Every 5 moves, a random event may occur!</li>
        </ol>
      `;
      content.appendChild(backBtn());
      panel.appendChild(content);
      return panel;
    }
    function backBtn() {
      const btn = document.createElement('button');
      btn.className = "back-btn";
      btn.innerText = "Back";
      btn.onclick = ()=>{screen="menu"; render();};
      return btn;
    }
    function renderPlay() {
      const gs = gameState;
      // Main container
      const main = document.createElement('div');
      main.style.minHeight = "100vh";
      main.style.display = "flex";
      main.style.flexDirection = "column";
      main.style.alignItems = "stretch";
      main.style.justifyContent = "flex-start";

      // Topbar
      const topbar = document.createElement('div');
      topbar.className = "topbar";
      topbar.innerHTML = `
        <div class="moves-counter"><b>Moves Left: ${gs.movesLeft}</b></div>
        <div class="info-bar">
          <span><b>Mana:</b> ${gs.mana} <span style="color:#0ff;">💠</span></span>
          <span><b>Your:</b> ${countBoard(gs.board,0)} <span style="color:#fff;">⬜</span></span>
          <span><b>AI:</b> ${countBoard(gs.board,1)} <span style="color:#0ff;">⬛</span></span>
        </div>`;
      main.appendChild(topbar);

      // Main game area
      const gameMain = document.createElement('div');
      gameMain.className = "game-main";
      // Board
      const boardWrap = document.createElement('div');
      boardWrap.className = 'board-wrap';
      const boardDiv = document.createElement('div');
      boardDiv.className = "board";
      for (let r=0; r<BOARD_SIZE; r++) {
        for (let c=0; c<BOARD_SIZE; c++) {
          const cell = gs.board[r][c];
          const cellDiv = document.createElement('div');
          cellDiv.className = "board-cell";
          if (cell===0) cellDiv.classList.add("player");
          else if (cell===1) cellDiv.classList.add("ai");
          else if (typeof cell==='object' && cell.quantum) {
            cellDiv.classList.add("quantum");
            if (cell.visible) cellDiv.classList.add("visible");
          }
          // Last move highlight
          if ((gs.lastPlayerMove && gs.lastPlayerMove.r===r && gs.lastPlayerMove.c===c) ||
              (gs.lastAIMove && gs.lastAIMove.r===r && gs.lastAIMove.c===c)) {
            cellDiv.classList.add("last-move");
          }
          cellDiv.onclick = ()=>handleCellClick(r,c);
          // Quantum marker
          if (typeof cell==='object' && cell.quantum) {
            cellDiv.innerHTML = `<span style="position:absolute;left:2px;top:2px;font-size:1.1em;color:#fff;text-shadow:0 0 10px #44f;font-weight:bold;">Q</span>`;
          }
          if (gs.turn===0 && gs.lastAIMove && gs.lastAIMove.r===r && gs.lastAIMove.c===c) {
            cellDiv.style.opacity = 0.45;
            cellDiv.title = "Can't play in the same spot as the AI's last move!";
          }
          if (gs.turn===1 && gs.lastPlayerMove && gs.lastPlayerMove.r===r && gs.lastPlayerMove.c===c) {
            cellDiv.style.opacity = 0.45;
            cellDiv.title = "Can't play in the same spot as the player's last move!";
          }
          boardDiv.appendChild(cellDiv);
        }
      }
      boardWrap.appendChild(boardDiv);
      gameMain.appendChild(boardWrap);

      // Spells
      const spellsDiv = document.createElement('div');
      spellsDiv.className = 'spell-bar';
      if (spellsOwned.length === 0) {
        const msg = document.createElement('span');
        msg.className = "no-spells";
        msg.innerText = "No spells owned!";
        const shopBtn = document.createElement('button');
        shopBtn.className = "shop-link-btn";
        shopBtn.innerText = "Go to Shop";
        shopBtn.onclick = ()=>{screen="shop"; render();}
        spellsDiv.appendChild(msg);
        spellsDiv.appendChild(shopBtn);
      } else {
        SPELLS.forEach(spell=>{
          const owned = spellsOwned.includes(spell.key);
          const btn = document.createElement('button');
          btn.innerText = spell.name;
          btn.className = "spell-btn"+(gs.spellOn===spell.key?' selected':'');
          btn.disabled = !owned || gs.mana < spell.mana || (spell.key==="skip" && gs.usedSkip);
          btn.onclick = ()=>{
            if (!owned || gs.mana < spell.mana) return;
            if (spell.key==="collapse") { handleCollapseSpell(); return; }
            if (spell.key==="skip") { handleSkipSpell(); return; }
            gs.spellOn = spell.key;
            render();
          };
          spellsDiv.appendChild(btn);
        });
      }
      gameMain.appendChild(spellsDiv);

      // Spell info
      const spellInfo = document.createElement('div');
      spellInfo.className = 'spell-info';
      spellInfo.innerText = "(Select a spell to use it on your next move.)";
      gameMain.appendChild(spellInfo);

      main.appendChild(gameMain);

      // Winner overlay
      if (gs.winner) showOverlay(gs.winner, () => { screen="menu"; overlay = null; render(); });
      return main;
    }
    // --- Game Logic ---
    function countBoard(board, val) {
      let n=0;
      for (let r=0;r<BOARD_SIZE;r++)
        for (let c=0;c<BOARD_SIZE;c++)
          if (board[r][c]===val||(typeof board[r][c]==='object'&&board[r][c].quantum&&board[r][c].visible&&board[r][c].states.includes(val))) n++;
      return n;
    }
    function startGame() {
      let board = Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(1));
      for (let r=0;r<BOARD_SIZE;r++) for (let c=0;c<BOARD_SIZE;c++) 
        if (c<BOARD_SIZE/2) board[r][c]=0; // left half player, right half AI
      gameState = {
        board,
        mana: INIT_MANA,
        aiMana: INIT_MANA,
        turn: 0, // 0=player, 1=ai
        movesLeft: MAX_MOVES,
        winner: null,
        skip: false,
        quantumPieces: [],
        spellOn: null,
        usedSkip: false,
        lastPlayerMove: null,
        lastAIMove: null,
        movesPlayed: 0
      };
      screen = "play";
      render();
    }
    function handleCellClick(r,c) {
      const gs = gameState;
      if (gs.winner||gs.turn!==0) return;
      if (gs.lastAIMove && gs.lastAIMove.r===r && gs.lastAIMove.c===c) return;
      let cell = gs.board[r][c];
      if (typeof cell==='object' && cell.quantum) {
        if (!cell.visible) return;
        cell = cell.states[0];
      }
      if (cell!==1) return; // can only flip AI squares
      // Handle spell use
      if (gs.spellOn) {
        const spellKey = gs.spellOn;
        if (!spellsOwned.includes(spellKey)) return;
        if (spellKey==="quantum") {
          let states=[0,1];
          if (Math.random()<0.5) states.push(1);
          const trueState = states[Math.floor(Math.random()*states.length)];
          gs.board[r][c] = {quantum:true,states,trueState,visible:false};
          gs.mana -= SPELLS.find(s=>s.key===spellKey).mana;
          gs.spellOn = null;
          gs.movesLeft--;
          gs.turn = 1;
          gs.quantumPieces.push({r,c});
          gs.lastPlayerMove = {r,c};
          gs.movesPlayed++;
          checkRandomEvent(gs);
          render();
          setTimeout(()=>aiMove(gs),900);
          return;
        }
        if (spellKey==="fireball") {
          for (let dr=0;dr<4;dr++) for (let dc=0;dc<4;dc++) {
            let nr=r+dr-1, nc=c+dc-1;
            if (nr>=0&&nr<BOARD_SIZE&&nc>=0&&nc<BOARD_SIZE) {
              if (typeof gs.board[nr][nc]==='object'&&gs.board[nr][nc].quantum) gs.board[nr][nc]=gs.board[nr][nc].trueState;
              else gs.board[nr][nc]=0;
            }
          }
          gs.mana -= SPELLS.find(s=>s.key===spellKey).mana;
          gs.spellOn = null;
          gs.movesLeft--;
          gs.turn = 1;
          gs.lastPlayerMove = {r,c};
          gs.movesPlayed++;
          checkRandomEvent(gs);
          render();
          setTimeout(()=>aiMove(gs),900);
          return;
        }
      }
      // Standard flip
      flip(gs.board, r, c, 0);
      gs.movesLeft--;
      gs.turn = 1;
      gs.mana += MANA_REGEN;
      gs.lastPlayerMove = {r,c};
      gs.movesPlayed++;
      checkRandomEvent(gs);
      if (gs.movesLeft<=0) {
        const w = countBoard(gs.board,0), bl = countBoard(gs.board,1);
        endGame(w>bl?1:w<bl?0:null);
        return;
      }
      render();
      setTimeout(()=>aiMove(gs),900);
    }
    function flip(board, r, c, color) {
      const dirs = [[0,0],[-1,0],[1,0],[0,-1],[0,1]];
      for (const [dr,dc] of dirs) {
        let nr=r+dr,nc=c+dc;
        if (nr>=0&&nr<BOARD_SIZE&&nc>=0&&nc<BOARD_SIZE) {
          if (typeof board[nr][nc]==='object'&&board[nr][nc].quantum) board[nr][nc]=board[nr][nc].trueState;
          else board[nr][nc]=color;
        }
      }
    }
    function handleCollapseSpell() {
      const gs = gameState;
      if (!spellsOwned.includes("collapse")||gs.mana<SPELLS.find(s=>s.key==="collapse").mana) return;
      for (let r=0;r<BOARD_SIZE;r++) for (let c=0;c<BOARD_SIZE;c++)
        if (typeof gs.board[r][c]==='object'&&gs.board[r][c].quantum) gs.board[r][c]=gs.board[r][c].trueState;
      gs.mana -= SPELLS.find(s=>s.key==="collapse").mana;
      gs.spellOn = null;
      gs.movesLeft--;
      gs.turn = 1;
      gs.movesPlayed++;
      checkRandomEvent(gs);
      render();
      setTimeout(()=>aiMove(gs),900);
    }
    function handleSkipSpell() {
      const gs = gameState;
      if (!spellsOwned.includes("skip")||gs.mana<SPELLS.find(s=>s.key==="skip").mana||gs.usedSkip) return;
      gs.mana -= SPELLS.find(s=>s.key==="skip").mana;
      gs.skip = true;
      gs.usedSkip = true;
      gs.spellOn = null;
      gs.movesLeft--;
      gs.turn = 1;
      gs.movesPlayed++;
      checkRandomEvent(gs);
      render();
      setTimeout(()=>aiMove(gs),900);
    }
    function endGame(playerWon) {
      const gs = gameState;
      gs.winner = playerWon ? "You win! +10 coins" : playerWon===null ? "Draw!" : "AI wins!";
      if (playerWon) coins += 10;
      overlay = [gs.winner, () => { screen="menu"; overlay = null; render(); }];
      render();
    }
    function aiMove(gs) {
      if (gs.winner) return;
      if (gs.skip) { gs.skip=false; gs.turn=0; gs.usedSkip=true; gs.movesPlayed++; checkRandomEvent(gs); render(); return; }
      const moves=[];
      for (let r=0;r<BOARD_SIZE;r++)
        for (let c=0;c<BOARD_SIZE;c++)
          if (gs.board[r][c]===0) {
            if (gs.lastPlayerMove && gs.lastPlayerMove.r===r && gs.lastPlayerMove.c===c) continue;
            const b2 = JSON.parse(JSON.stringify(gs.board));
            flip(b2,r,c,1);
            const gain = countBoard(b2,1)-countBoard(gs.board,1);
            moves.push({r,c,gain,b2});
          }
      let move=null;
      if (moves.length===0) { gs.turn=0; render(); return; }
      let sortedMoves=[...moves].sort((a,b)=>b.gain-a.gain);
      if (difficulty===0) {
        let top=sortedMoves.slice(0,25); move=top[Math.floor(Math.random()*top.length)];
      } else if (difficulty===1) {
        let top=sortedMoves.slice(0,15); move=top[Math.floor(Math.random()*top.length)];
      } else if (difficulty===2) {
        let top=sortedMoves.slice(0,3); move=top[Math.floor(Math.random()*top.length)];
      } else if (difficulty===3) {
        let best=-Infinity;
        for (const m of sortedMoves.slice(0,6)) {
          let bestReply=-Infinity;
          for (let rr=0;rr<BOARD_SIZE;rr++) for (let cc=0;cc<BOARD_SIZE;cc++)
            if (m.b2[rr][cc]===1) {
              if (m.r===rr && m.c===cc) continue;
              let b3=JSON.parse(JSON.stringify(m.b2));
              flip(b3,rr,cc,0);
              let v=countBoard(b3,1)-countBoard(m.b2,1);
              if (v>bestReply) bestReply=v;
            }
          let value = m.gain-(bestReply||0);
          if (value>best) { best=value; move=m; }
        }
      }
      if (!move) move=sortedMoves[0];
      if (!move) { gs.turn=0; render(); return; }
      gs.board = move.b2;
      for (let r=0;r<BOARD_SIZE;r++)
        for (let c=0;c<BOARD_SIZE;c++)
          if (typeof gs.board[r][c]==='object'&&gs.board[r][c].quantum&&!gs.board[r][c].visible)
            gs.board[r][c].visible=true;
      gs.movesLeft--;
      gs.aiMana+=MANA_REGEN;
      gs.turn=0;
      gs.lastAIMove = {r:move.r,c:move.c};
      gs.movesPlayed++;
      checkRandomEvent(gs);
      if (gs.movesLeft<=0) {
        const w = countBoard(gs.board,0), bl = countBoard(gs.board,1);
        endGame(w>bl?1:w<bl?0:null);
        return;
      }
      render();
    }
    function checkRandomEvent(gs) {
      if (!gs.winner && gs.movesPlayed > 0 && gs.movesPlayed % 5 === 0) {
        if (Math.random() < 0.5) {
          const event = RANDOM_EVENTS[Math.floor(Math.random()*RANDOM_EVENTS.length)];
          event.run(gs);
        }
      }
    }
    // Overlay
    function showOverlay(msg, cb) {
      overlay=[msg, cb];
      render();
    }
    function renderOverlay(msg, cb) {
      const div = document.createElement('div');
      div.className = "overlay";
      div.onclick = ()=>{
        overlay=null;
        if (cb) cb();
        render();
      };
      div.innerHTML = `<div class="overlay-inner">${msg}<div class="small">(Click to continue)</div></div>`;
      return div;
    }
    window.onload = render;
  </script>
</body>
</html>
