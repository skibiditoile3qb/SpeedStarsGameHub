


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quantum Flip Game</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://fonts.googleapis.com/css?family=Orbitron:wght@700&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0; padding: 0;
      font-family: 'Orbitron', Arial, sans-serif;
      background: #10131a;
      min-height: 100vh;
      min-width: 100vw;
      width: 100vw;
      height: 100vh;
      overflow-x: hidden;
      overflow-y: auto;
    }
    #root {
      width: 100vw;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
      position: relative;
      z-index: 0;
      background: #10131a;
    }
    .topbar {
      width: 100vw;
      min-height: 60px;
      background: #181f2a;
      border-bottom: 1.5px solid #232b39;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      z-index: 2;
      position: relative;
      box-shadow: 0 2px 12px #0003;
    }
    .moves-counter {
      font-family: 'Orbitron', monospace, Arial, sans-serif;
      font-size: 2em;
      color: #18e6e6;
      margin-top: 4px;
      font-weight: bold;
      letter-spacing: 2px;
      background: none;
      padding: 3px 0 2px 0;
      border-radius: 12px;
      text-shadow: 0 2px 0 #fff3, 0 0 6px #18e6e6a1;
    }
    .info-bar {
      width: 100vw;
      font-size: 1em;
      color: #18e6e6;
      background: none;
      display: flex;
      justify-content: center;
      gap: 32px;
      align-items: center;
      margin: 0;
      padding: 2px 0 8px 0;
      font-family: inherit;
      font-weight: 600;
      letter-spacing: 1px;
    }
    .game-main {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: 100vw;
      min-height: 0;
      background: #10131a;
      position: relative;
    }
    .board-wrap {
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 26px;
      margin-bottom: 8px;
      min-height: 0;
      z-index: 1;
    }
    .board {
      display: grid;
      grid-template-rows: repeat(10,1fr);
      grid-template-columns: repeat(10,1fr);
      gap: 3px;
      background: #12141e;
      border-radius: 18px;
      margin: 0 auto;
      width: min(70vw, 70vh);
      height: min(70vw, 70vh);
      max-width: 97vw;
      max-height: 97vw;
      aspect-ratio: 1/1;
      position: relative;
      border: 1.5px solid #232b39;
      box-shadow: 0 2px 24px #0007;
      transition: box-shadow 0.2s;
    }
    .board-cell {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      border: 2px solid #2cf3fb;
      box-sizing: border-box;
      font-size: 1.15em;
      cursor: pointer;
      background: #191b22;
      position: relative;
      user-select: none;
      box-shadow: 0 1px 2.5px #0005;
      overflow: hidden;
      z-index: 1;
      transition: background 0.22s, border 0.15s, box-shadow 0.12s, filter 0.18s, transform 0.23s;
      filter: brightness(1);
      animation: none !important;
    }
    .board-cell.player {
      background: #fff;
      border: 2.5px solid #dbeafe;
      box-shadow: 0 0 5px #dbeafe77;
    }
    .board-cell.ai {
      background: #20242b;
      border: 2.5px solid #18e6e6;
      box-shadow: 0 0 5px #18e6e655;
    }
    .board-cell.quantum {
      background: repeating-linear-gradient(45deg, #3ff 0 5px, #fff 6px 14px);
      border: 2.5px dashed #44f;
    }
    .board-cell.quantum.visible {
      background: linear-gradient(120deg,#0ff,#44f 60%);
      border-style: solid;
    }
    .board-cell.last-move {
      outline: 2.5px solid #f00 !important;
      z-index: 2;
      box-shadow: 0 0 10px #f08a;
    }
    .board-cell:active, .board-cell.flipping {
      transform: scale(1.18) rotate(-2deg);
      z-index: 2;
      filter: brightness(1.25);
      transition: transform 0.15s, filter 0.12s;
    }
    .board-cell.flipping {
      animation: flipEffect 0.34s cubic-bezier(.53,2.3,.44,.98);
    }
    @keyframes flipEffect {
      0% { transform: scale(1) rotate(0deg);}
      45% { transform: scale(1.26) rotate(4deg);}
      100% { transform: scale(1) rotate(0deg);}
    }
    .board-cell:hover {
      filter: brightness(1.12);
      border-color: #ff0;
      z-index: 2;
    }
    .spell-bar {
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0 0 16px 0;
      flex-wrap: wrap;
      min-height: 52px;
      position: relative;
      z-index: 2;
      background: none;
    }
    .spell-btn {
      margin: 7px 11px 7px 0;
      padding: 10px 30px;
      background: #fff;
      color: #222;
      border: 2.5px solid #18e6e6;
      border-radius: 10px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1.15em;
      box-shadow: 0 0 4px #18e6e655;
      transition: background .13s, color .13s, border 0.12s;
      outline: none;
      letter-spacing: 1.2px;
      text-shadow: none;
      filter: none;
    }
    .spell-btn:disabled { background: #eee; color: #bbb; cursor: not-allowed; border:2.5px solid #bbb;}
    .spell-btn.selected { outline: 2px solid #ff0; background: #232b39; color:#18e6e6; border:2.5px solid #ff0;}
    .spell-info {
      font-size: 1em;
      color: #18e6e6;
      margin: 4px 0 0 0;
      text-align: center;
      min-height: 28px;
      font-family: inherit;
      font-weight: 600;
      letter-spacing: 1px;
    }
    .no-spells {
      color: #fc0;
      font-weight: bold;
      font-size: 1.12em;
      margin-right: 14px;
      text-shadow: none;
      font-family:inherit;
    }
    .shop-link-btn {
      background: #ff0;
      color: #232b39;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1em;
      box-shadow: none;
      padding: 8px 24px;
      margin-left: 14px;
      transition: background .13s, color .13s;
      outline: none;
      font-family:inherit;
    }
    .shop-link-btn:hover { background: #18e6e6; color:#222;}
    .fullscreen-panel {
      width: 100vw;
      height: 100vh;
      min-height: 100vh;
      min-width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #10131a;
      position: absolute;
      top: 0; left: 0;
      z-index: 1;
    }
    .panel-content {
      width: 100vw;
      max-width: 700px;
      margin: 0 auto;
      padding: 0 3vw;
      text-align: center;
      color: #fff;
      margin-top: 4vh;
      margin-bottom: 4vh;
      z-index: 2;
      background: #181f2a;
      border-radius:20px;
      box-shadow: 0 0 36px #0003;
      border: 1.5px solid #232b39;
    }
    h1, h2 { color: #18e6e6; text-shadow: 0 0 7px #fff2; font-family: 'Orbitron', Arial, sans-serif; }
    .coin {
      color: #18e6e6;
      font-weight: bold;
      text-shadow: none;
      font-size: 1.12em;
    }
    .menu-btn {
      width: 320px;
      max-width: 80vw;
      margin: 18px auto;
      padding: 18px 0;
      font-size: 1.3em;
      background: #fff;
      color: #18e6e6;
      border-radius: 10px;
      border: 2px solid #18e6e6;
      box-shadow: none;
      cursor: pointer;
      font-weight: bold;
      letter-spacing: 1px;
      transition: background .12s, color .12s;
      text-shadow: none;
      display:block;
      font-family:inherit;
    }
    .menu-btn:hover { background: #18e6e6; color: #fff;}
    .back-btn {
      padding: 13px 36px;
      margin-top: 32px;
      background: #232b39;
      color: #fff;
      border: 2px solid #18e6e6;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1.1em;
      font-weight: bold;
      box-shadow: none;
      transition: background .14s, color .14s;
      font-family:inherit;
    }
    .back-btn:hover { background: #18e6e6; color: #222; }
    .shop-spell {
      border: 1.5px solid #18e6e6;
      border-radius: 10px;
      padding: 17px 6px 17px 12px;
      margin: 13px 2px;
      background: #181f2a;
      text-align: left;
      font-size: 1.08em;
      box-shadow: none;
      max-width: 530px;
      margin-left:auto;
      margin-right:auto;
      font-family:inherit;
      transition: background .12s, border .12s;
    }
    .shop-spell.owned { background: #e7ffe7; border-color:#bcb;}
    .shop-spell .spell-title { font-weight: bold; font-size: 1.12em; color:#18e6e6;}
    .shop-spell .spell-desc { font-size: 1em; color: #bff; white-space: pre-line; }
    .shop-spell .spell-cost { color: #18e6e6; font-weight: bold; }
    .shop-spell button {
      margin-top: 7px;
      background: #18e6e6;
      color: #fff; border: none; border-radius: 7px;
      padding: 8px 20px; cursor: pointer;
      font-weight: bold;
      float: right;
      font-size:1em;
      box-shadow: none;
      transition: background .13s, color .13s;
      font-family:inherit;
    }
    .shop-spell button:disabled { background: #bbb; color:#eee; cursor: not-allowed; }
    .difficulty-select {
      margin-top: 24px;
      font-size: 1.12em;
      padding: 10px 24px;
      border-radius: 9px;
      border: 1.5px solid #18e6e6;
      background: #fff;
      color:#18e6e6;
      text-align:center;
      font-family:inherit;
    }
    .overlay {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      background: #000a;
      z-index: 1000;
      display: flex;
      align-items: center; justify-content: center;
    }
    .overlay-inner {
      background: #fff;
      color: #181f2a;
      padding: 44px 36px 34px 36px;
      border-radius: 22px;
      min-width: 320px;
      box-shadow: 0 10px 60px #0003;
      text-align: center;
      font-size: 2em;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      font-family:inherit;
      border: 2.5px solid #18e6e6;
    }
    .overlay-inner .small {
      font-size: 1.08em;
      margin-top: 30px;
      color: #18e6e6;
    }
    @media (max-width: 800px) {
      .board { max-width: 97vw; max-height: 97vw; }
      .panel-content { max-width: 95vw;}
      .shop-spell { max-width: 96vw;}
    }
    @media (max-width: 600px) {
      .board { max-width: 99vw; max-height: 99vw; }
      .panel-content { max-width: 99vw;}
      .shop-spell { max-width: 99vw;}
      .board-cell { font-size: 0.7em; }
      .spell-btn { font-size: 0.7em; padding: 7px 10px;}
      .moves-counter { font-size: 1.1em;}
      .info-bar { font-size: 0.9em; gap: 16px;}
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
    let coins = 0;
    let spellsOwned = [];
    let difficulty = 0;
    let screen = "menu";
    let gameState = null;
    let overlay = null;
    let flipQueue = [];
    const SPELLS = [
      {
        key: "quantum",
        name: "Quantum Split",
        desc: `A single move, many futures.\nSplits a piece into 2-3 possible states; opponent sees all, but only one is real—revealed when targeted.`,
        cost: 30,
        mana: 20
      },
      {
        key: "collapse",
        name: "Waveform Collapse",
        desc: `Everything becomes... definite.\nCollapses all superpositioned pieces on the board to their actual states. Good for revealing enemy tricks or final strikes.`,
        cost: 20,
        mana: 50
      },
      {
        key: "fireball",
        name: "Fireball",
        desc: `Casts a fireball in a 4x4 area, flipping all squares inside.`,
        cost: 18,
        mana: 40
      },
      {
        key: "skip",
        name: "Skip",
        desc: `Skips the opponent's move, giving you two in a row.`,
        cost: 25,
        mana: 35
      }
    ];
    const DIFFICULTY_LEVELS = ["Easy", "Medium", "Hard", "Extreme"];
    const BOARD_SIZE = 10, INIT_MANA = 100, MANA_REGEN = 8, MAX_MOVES = 70;
    const RANDOM_EVENTS = [
      {
        name: "Flip Random Row",
        run(gs) {
          const row = Math.floor(Math.random() * BOARD_SIZE);
          for (let c = 0; c < BOARD_SIZE; c++)
            flip(gs.board, row, c, Math.random() < 0.5 ? 0 : 1);
          showOverlay(`Random Event: A mysterious force flips all of row ${row+1}!`);
        }
      },
      {
        name: "Flip Random Column",
        run(gs) {
          const col = Math.floor(Math.random() * BOARD_SIZE);
          for (let r = 0; r < BOARD_SIZE; r++)
            flip(gs.board, r, col, Math.random() < 0.5 ? 0 : 1);
          showOverlay(`Random Event: Lightning strikes column ${col+1} and flips it!`);
        }
      },
      {
        name: "Color Surge",
        run(gs) {
          for(let i=0;i<6;i++) {
            let r = Math.floor(Math.random()*BOARD_SIZE);
            let c = Math.floor(Math.random()*BOARD_SIZE);
            gs.board[r][c] = Math.random()<0.5?0:1;
          }
          showOverlay("Random Event: Color Surge! 6 random tiles have shifted color.");
        }
      },
      {
        name: "Mana Burst",
        run(gs) {
          gs.mana += 15;
          gs.aiMana += 15;
          showOverlay("Random Event: Mana Burst! Both players gain 15 mana.");
        }
      },
      {
        name: "Quantum Storm",
        run(gs) {
          for(let i=0;i<4;i++) {
            let r = Math.floor(Math.random()*BOARD_SIZE);
            let c = Math.floor(Math.random()*BOARD_SIZE/2) + BOARD_SIZE/2;
            if (gs.board[r][c] === 1) {
              let states = [0,1];
              if (Math.random()<0.5) states.push(1);
              const trueState = states[Math.floor(Math.random()*states.length)];
              gs.board[r][c] = {quantum:true,states,trueState,visible:false};
            }
          }
          showOverlay("Random Event: Quantum Storm! Some AI squares split into quantum states.");
        }
      }
    ];

    function render() {
      const root = document.getElementById('root');
      root.innerHTML = '';
      if (screen === "play") {
        root.appendChild(renderPlay());
      } else if (screen === "menu") {
        root.appendChild(renderMenu());
      } else if (screen === "settings") {
        root.appendChild(renderSettings());
      } else if (screen === "shop") {
        root.appendChild(renderShop());
      } else if (screen === "tutorial") {
        root.appendChild(renderTutorial());
      }
      if (overlay) root.appendChild(renderOverlay(...overlay));
    }
    function renderMenu() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.innerHTML = `
        <h1>Quantum Flip</h1>
        <div style="margin:16px 0 40px 0;">
          <span class="coin" style="font-size:2.2em;">Coins: ${coins} 🪙</span>
        </div>
      `;
      content.appendChild(menuBtn("Play", ()=>startGame()));
      content.appendChild(menuBtn("Tutorial", ()=>{screen="tutorial"; render();}));
      content.appendChild(menuBtn("Shop", ()=>{screen="shop"; render();}));
      content.appendChild(menuBtn("Settings", ()=>{screen="settings"; render();}));
      const by = document.createElement('div');
      by.style.marginTop = "53px";
      by.style.fontSize = "1.1em";
      by.style.color = "#0ff";
      by.innerHTML = 'by <b>skibiditoile3qb</b> | neon vanilla JS demo';
      content.appendChild(by);
      panel.appendChild(content);
      return panel;
    }
    function menuBtn(text, cb) {
      const btn = document.createElement('button');
      btn.className = "menu-btn";
      btn.innerText = text;
      btn.onclick = cb;
      return btn;
    }
    function renderSettings() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.innerHTML = `<h2>Settings</h2>
        <div style="margin-bottom:24px">
          <b>AI Difficulty:</b>
          <br>
          <select class="difficulty-select" id="diffsel">
            ${DIFFICULTY_LEVELS.map((d,i)=>`<option value="${i}"${i==difficulty?' selected':''}>${d}</option>`).join('')}
          </select>
        </div>
      `;
      setTimeout(()=>{
        document.getElementById('diffsel').onchange = e=>{
          difficulty = +e.target.value;
        };
      },10);
      content.appendChild(backBtn());
      panel.appendChild(content);
      return panel;
    }
    function renderShop() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.innerHTML = `<div style="margin-bottom:14px;">
        <b>Coins:</b> <span class="coin">${coins} 🪙</span>
      </div>
      <h2>Shop</h2>`;
      SPELLS.forEach(spell=>{
        const owned = spellsOwned.includes(spell.key);
        const spellDiv = document.createElement('div');
        spellDiv.className = 'shop-spell'+(owned?' owned':'');
        spellDiv.innerHTML = `
          <div class="spell-title">${spell.name}</div>
          <div class="spell-desc">${spell.desc}</div>
          <div>
            <span class="spell-cost">${spell.cost} 🪙</span>
            <span style="margin-left:12px; color:#0ff;">Use: ${spell.mana} mana</span>
          </div>
        `;
        const btn = document.createElement('button');
        btn.innerText = owned ? "Owned" : "Buy";
        btn.disabled = owned || coins < spell.cost;
        btn.onclick = ()=>{
          if (owned || coins < spell.cost) return;
          coins -= spell.cost;
          spellsOwned.push(spell.key);
          render();
        };
        spellDiv.appendChild(btn);
        content.appendChild(spellDiv);
      });
      content.appendChild(backBtn());
      panel.appendChild(content);
      return panel;
    }
    function renderTutorial() {
      const panel = document.createElement('div');
      panel.className = "fullscreen-panel";
      const content = document.createElement('div');
      content.className = "panel-content";
      content.style.textAlign = "left";
      content.style.maxWidth = "650px";
      content.innerHTML = `
        <h2>Tutorial</h2>
        <ol>
          <li><b>The Goal:</b> Flip as many tiles to your color (white-neon) as possible before 70-move countdown ends.</li>
          <li><b>Turns:</b> You and the AI take turns. Each turn, click any <b>AI (aqua)</b> square; it and all adjacent squares (not corners) flip.</li>
          <li><b>Mana:</b> Each turn you regain 8 mana. Spells cost mana to cast.</li>
          <li><b>Spells:</b> Buy spells in the Shop, then select a spell in-game to use its effect!</li>
          <li><b>End:</b> When moves run out, whoever has more squares of their color wins and gets 10 coins!</li>
          <li><b>AI:</b> The higher the difficulty, the smarter the AI's moves. AI/Player cannot repeat the other's last move.</li>
          <li><b>Random Events:</b> Every 5 moves, a random event may occur!</li>
        </ol>
      `;
      content.appendChild(backBtn());
      panel.appendChild(content);
      return panel;
    }
    function backBtn() {
      const btn = document.createElement('button');
      btn.className = "back-btn";
      btn.innerText = "Back";
      btn.onclick = ()=>{screen="menu"; render();};
      return btn;
    }
    function renderPlay() {
      const gs = gameState;
      const main = document.createElement('div');
      main.style.minHeight = "100vh";
      main.style.display = "flex";
      main.style.flexDirection = "column";
      main.style.alignItems = "stretch";
      main.style.justifyContent = "flex-start";
      const topbar = document.createElement('div');
      topbar.className = "topbar";
      topbar.innerHTML = `
        <div class="moves-counter"><b>Moves Left: ${gs.movesLeft}</b></div>
        <div class="info-bar">
          <span><b>Mana:</b> ${gs.mana} <span style="color:#18e6e6;">💠</span></span>
          <span><b>Your:</b> ${countBoard(gs.board,0)} <span style="color:#fff;">⬜</span></span>
          <span><b>AI:</b> ${countBoard(gs.board,1)} <span style="color:#18e6e6;">⬛</span></span>
        </div>`;
      main.appendChild(topbar);
      const gameMain = document.createElement('div');
      gameMain.className = "game-main";
      const boardWrap = document.createElement('div');
      boardWrap.className = 'board-wrap';
      const boardDiv = document.createElement('div');
      boardDiv.className = "board";
      for (let r=0; r<BOARD_SIZE; r++) {
        for (let c=0; c<BOARD_SIZE; c++) {
          const cell = gs.board[r][c];
          const cellDiv = document.createElement('div');
          cellDiv.className = "board-cell";
          if (cell===0) cellDiv.classList.add("player");
          else if (cell===1) cellDiv.classList.add("ai");
          else if (typeof cell==='object' && cell.quantum) {
            cellDiv.classList.add("quantum");
            if (cell.visible) cellDiv.classList.add("visible");
          }
          if ((gs.lastPlayerMove && gs.lastPlayerMove.r===r && gs.lastPlayerMove.c===c) ||
              (gs.lastAIMove && gs.lastAIMove.r===r && gs.lastAIMove.c===c)) {
            cellDiv.classList.add("last-move");
          }
          if (flipQueue.some(x=>x.r===r&&x.c===c)) {
            cellDiv.classList.add("flipping");
          }
          cellDiv.onclick = ()=>handleCellClick(r,c);
          if (typeof cell==='object' && cell.quantum) {
            cellDiv.innerHTML = `<span style="position:absolute;left:2px;top:2px;font-size:1.1em;color:#fff;text-shadow:0 0 10px #44f;font-weight:bold;">Q</span>`;
          }
          if (gs.turn===0 && gs.lastAIMove && gs.lastAIMove.r===r && gs.lastAIMove.c===c) {
            cellDiv.style.opacity = 0.45;
            cellDiv.title = "Can't play in the same spot as the AI's last move!";
          }
          if (gs.turn===1 && gs.lastPlayerMove && gs.lastPlayerMove.r===r && gs.lastPlayerMove.c===c) {
            cellDiv.style.opacity = 0.45;
            cellDiv.title = "Can't play in the same spot as the player's last move!";
          }
          boardDiv.appendChild(cellDiv);
        }
      }
      boardWrap.appendChild(boardDiv);
      gameMain.appendChild(boardWrap);
      const spellsDiv = document.createElement('div');
      spellsDiv.className = 'spell-bar';
      if (spellsOwned.length === 0) {
        const msg = document.createElement('span');
        msg.className = "no-spells";
        msg.innerText = "No spells owned!";
        const shopBtn = document.createElement('button');
        shopBtn.className = "shop-link-btn";
        shopBtn.innerText = "Go to Shop";
        shopBtn.onclick = ()=>{screen="shop"; render();}
        spellsDiv.appendChild(msg);
        spellsDiv.appendChild(shopBtn);
      } else {
        SPELLS.forEach(spell=>{
          const owned = spellsOwned.includes(spell.key);
          const btn = document.createElement('button');
          btn.innerText = spell.name;
          btn.className = "spell-btn"+(gs.spellOn===spell.key?' selected':'');
          btn.disabled = !owned || gs.mana < spell.mana || (spell.key==="skip" && gs.usedSkip);
          btn.onclick = ()=>{
            if (!owned || gs.mana < spell.mana) return;
            if (spell.key==="collapse") { handleCollapseSpell(); return; }
            if (spell.key==="skip") { handleSkipSpell(); return; }
            gs.spellOn = spell.key;
            render();
          };
          spellsDiv.appendChild(btn);
        });
      }
      gameMain.appendChild(spellsDiv);
      const spellInfo = document.createElement('div');
      spellInfo.className = 'spell-info';
      spellInfo.innerText = "(Select a spell to use it on your next move.)";
      gameMain.appendChild(spellInfo);
      main.appendChild(gameMain);
      if (gs.winner) showOverlay(gs.winner, () => { screen="menu"; overlay = null; render(); });
      return main;
    }
    function countBoard(board, val) {
      let n=0;
      for (let r=0;r<BOARD_SIZE;r++)
        for (let c=0;c<BOARD_SIZE;c++)
          if (board[r][c]===val||(typeof board[r][c]==='object'&&board[r][c].quantum&&board[r][c].visible&&board[r][c].states.includes(val))) n++;
      return n;
    }
    function startGame() {
      let board = Array.from({length:BOARD_SIZE},()=>Array(BOARD_SIZE).fill(1));
      for (let r=0;r<BOARD_SIZE;r++) for (let c=0;c<BOARD_SIZE;c++) 
        if (c<BOARD_SIZE/2) board[r][c]=0; // left half player, right half AI
      gameState = {
        board,
        mana: INIT_MANA,
        aiMana: INIT_MANA,
        turn: 0,
        movesLeft: MAX_MOVES,
        winner: null,
        skip: false,
        quantumPieces: [],
        spellOn: null,
        usedSkip: false,
        lastPlayerMove: null,
        lastAIMove: null,
        movesPlayed: 0
      };
      screen = "play";
      render();
    }
    function handleCellClick(r,c) {
      const gs = gameState;
      if (gs.winner||gs.turn!==0) return;
      if (gs.lastAIMove && gs.lastAIMove.r===r && gs.lastAIMove.c===c) return;
      let cell = gs.board[r][c];
      if (typeof cell==='object' && cell.quantum) {
        if (!cell.visible) return;
        cell = cell.states[0];
      }
      if (cell!==1) return;
      if (gs.spellOn) {
        const spellKey = gs.spellOn;
        if (!spellsOwned.includes(spellKey)) return;
        if (spellKey==="quantum") {
          let states=[0,1];
          if (Math.random()<0.5) states.push(1);
          const trueState = states[Math.floor(Math.random()*states.length)];
          gs.board[r][c] = {quantum:true,states,trueState,visible:false};
          gs.mana -= SPELLS.find(s=>s.key===spellKey).mana;
          gs.spellOn = null;
          gs.movesLeft--;
          gs.turn = 1;
          gs.quantumPieces.push({r,c});
          gs.lastPlayerMove = {r,c};
          gs.movesPlayed++;
          checkRandomEvent(gs);
          render();
          setTimeout(()=>aiMove(gs),900);
          return;
        }
        if (spellKey==="fireball") {
          for (let dr=0;dr<4;dr++) for (let dc=0;dc<4;dc++) {
            let nr=r+dr-1, nc=c+dc-1;
            if (nr>=0&&nr<BOARD_SIZE&&nc>=0&&nc<BOARD_SIZE) {
              if (typeof gs.board[nr][nc]==='object'&&gs.board[nr][nc].quantum) gs.board[nr][nc]=gs.board[nr][nc].trueState;
              else gs.board[nr][nc]=0;
            }
          }
          gs.mana -= SPELLS.find(s=>s.key===spellKey).mana;
          gs.spellOn = null;
          gs.movesLeft--;
          gs.turn = 1;
          gs.lastPlayerMove = {r,c};
          gs.movesPlayed++;
          checkRandomEvent(gs);
          render();
          setTimeout(()=>aiMove(gs),900);
          return;
        }
      }
      flip(gs.board, r, c, 0);
      gs.movesLeft--;
      gs.turn = 1;
      gs.mana += MANA_REGEN;
      gs.lastPlayerMove = {r,c};
      gs.movesPlayed++;
      checkRandomEvent(gs);
      if (gs.movesLeft<=0) {
        const w = countBoard(gs.board,0), bl = countBoard(gs.board,1);
        endGame(w>bl?1:w<bl?0:null);
        return;
      }
      render();
      setTimeout(()=>aiMove(gs),900);
    }
    function flip(board, r, c, color) {
      const dirs = [[0,0],[-1,0],[1,0],[0,-1],[0,1]];
      flipQueue = [];
      for (const [dr,dc] of dirs) {
        let nr=r+dr,nc=c+dc;
        if (nr>=0&&nr<BOARD_SIZE&&nc>=0&&nc<BOARD_SIZE) {
          if (typeof board[nr][nc]==='object'&&board[nr][nc].quantum) board[nr][nc]=board[nr][nc].trueState;
          else board[nr][nc]=color;
          flipQueue.push({r:nr, c:nc});
        }
      }
      render();
      setTimeout(()=>{ flipQueue = []; render(); }, 350);
    }
    function handleCollapseSpell() {
      const gs = gameState;
      if (!spellsOwned.includes("collapse")||gs.mana<SPELLS.find(s=>s.key==="collapse").mana) return;
      for (let r=0;r<BOARD_SIZE;r++) for (let c=0;c<BOARD_SIZE;c++)
        if (typeof gs.board[r][c]==='object'&&gs.board[r][c].quantum) gs.board[r][c]=gs.board[r][c].trueState;
      gs.mana -= SPELLS.find(s=>s.key==="collapse").mana;
      gs.spellOn = null;
      gs.movesLeft--;
      gs.turn = 1;
      gs.movesPlayed++;
      checkRandomEvent(gs);
      render();
      setTimeout(()=>aiMove(gs),900);
    }
    function handleSkipSpell() {
      const gs = gameState;
      if (!spellsOwned.includes("skip")||gs.mana<SPELLS.find(s=>s.key==="skip").mana||gs.usedSkip) return;
      gs.mana -= SPELLS.find(s=>s.key==="skip").mana;
      gs.skip = true;
      gs.usedSkip = true;
      gs.spellOn = null;
      gs.movesLeft--;
      gs.turn = 1;
      gs.movesPlayed++;
      checkRandomEvent(gs);
      render();
      setTimeout(()=>aiMove(gs),900);
    }
    function endGame(playerWon) {
      const gs = gameState;
      gs.winner = playerWon ? "You win! +10 coins" : playerWon===null ? "Draw!" : "AI wins!";
      if (playerWon) coins += 10;
      overlay = [gs.winner, () => { screen="menu"; overlay = null; render(); }];
      render();
    }
    function aiMove(gs) {
      if (gs.winner) return;
      if (gs.skip) { gs.skip=false; gs.turn=0; gs.usedSkip=true; gs.movesPlayed++; checkRandomEvent(gs); render(); return; }
      const moves=[];
      for (let r=0;r<BOARD_SIZE;r++)
        for (let c=0;c<BOARD_SIZE;c++)
          if (gs.board[r][c]===0) {
            if (gs.lastPlayerMove && gs.lastPlayerMove.r===r && gs.lastPlayerMove.c===c) continue;
            const b2 = JSON.parse(JSON.stringify(gs.board));
            flip(b2,r,c,1);
            const gain = countBoard(b2,1)-countBoard(gs.board,1);
            moves.push({r,c,gain,b2});
          }
      let move=null;
      if (moves.length===0) { gs.turn=0; render(); return; }
      let sortedMoves=[...moves].sort((a,b)=>b.gain-a.gain);
      if (difficulty===0) {
        let top=sortedMoves.slice(0,25); move=top[Math.floor(Math.random()*top.length)];
      } else if (difficulty===1) {
        let top=sortedMoves.slice(0,15); move=top[Math.floor(Math.random()*top.length)];
      } else if (difficulty===2) {
        let top=sortedMoves.slice(0,3); move=top[Math.floor(Math.random()*top.length)];
      } else if (difficulty===3) {
        let best=-Infinity;
        for (const m of sortedMoves.slice(0,6)) {
          let bestReply=-Infinity;
          for (let rr=0;rr<BOARD_SIZE;rr++) for (let cc=0;cc<BOARD_SIZE;cc++)
            if (m.b2[rr][cc]===1) {
              if (m.r===rr && m.c===cc) continue;
              let b3=JSON.parse(JSON.stringify(m.b2));
              flip(b3,rr,cc,0);
              let v=countBoard(b3,1)-countBoard(m.b2,1);
              if (v>bestReply) bestReply=v;
            }
          let value = m.gain-(bestReply||0);
          if (value>best) { best=value; move=m; }
        }
      }
      if (!move) move=sortedMoves[0];
      if (!move) { gs.turn=0; render(); return; }
      gs.board = move.b2;
      for (let r=0;r<BOARD_SIZE;r++)
        for (let c=0;c<BOARD_SIZE;c++)
          if (typeof gs.board[r][c]==='object'&&gs.board[r][c].quantum&&!gs.board[r][c].visible)
            gs.board[r][c].visible=true;
      gs.movesLeft--;
      gs.aiMana+=MANA_REGEN;
      gs.turn=0;
      gs.lastAIMove = {r:move.r,c:move.c};
      gs.movesPlayed++;
      checkRandomEvent(gs);
      if (gs.movesLeft<=0) {
        const w = countBoard(gs.board,0), bl = countBoard(gs.board,1);
        endGame(w>bl?1:w<bl?0:null);
        return;
      }
      render();
    }
    function checkRandomEvent(gs) {
      if (!gs.winner && gs.movesPlayed > 0 && gs.movesPlayed % 5 === 0) {
        if (Math.random() < 0.5) {
          const event = RANDOM_EVENTS[Math.floor(Math.random()*RANDOM_EVENTS.length)];
          event.run(gs);
        }
      }
    }
    function showOverlay(msg, cb) {
      overlay=[msg, cb];
      render();
    }
    function renderOverlay(msg, cb) {
      const div = document.createElement('div');
      div.className = "overlay";
      div.onclick = ()=>{
        overlay=null;
        if (cb) cb();
        render();
      };
      div.innerHTML = `<div class="overlay-inner">${msg}<div class="small">(Click to continue)</div></div>`;
      return div;
    }
    window.onload = render;
  </script>
</body>
</html>

















